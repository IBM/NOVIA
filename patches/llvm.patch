diff -ruN llvm-project/llvm/cmake/modules/AddLLVM.cmake /home/dtrilla/git/novia/llvm-project/llvm/cmake/modules/AddLLVM.cmake
--- llvm-project/llvm/cmake/modules/AddLLVM.cmake	2023-05-24 11:35:47.012295744 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/cmake/modules/AddLLVM.cmake	2022-02-01 09:13:46.423669026 -0500
@@ -263,7 +263,7 @@
           set_property(TARGET ${target_name} APPEND_STRING PROPERTY
                        LINK_FLAGS " -Wl,-z,discard-unused=sections")
         endif()
-      elseif(NOT MSVC AND NOT CMAKE_SYSTEM_NAME MATCHES "OpenBSD|AIX|OS390")
+      elseif(NOT MSVC AND NOT CMAKE_SYSTEM_NAME MATCHES "AIX|OS390")
         # TODO Revisit this later on z/OS.
         set_property(TARGET ${target_name} APPEND_STRING PROPERTY
                      LINK_FLAGS " -Wl,--gc-sections")
diff -ruN llvm-project/llvm/cmake/modules/HandleLLVMOptions.cmake /home/dtrilla/git/novia/llvm-project/llvm/cmake/modules/HandleLLVMOptions.cmake
--- llvm-project/llvm/cmake/modules/HandleLLVMOptions.cmake	2023-05-24 11:35:47.012295744 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/cmake/modules/HandleLLVMOptions.cmake	2022-02-01 09:13:46.423669026 -0500
@@ -316,12 +316,11 @@
     # Note: GCC<10.3 has a bug on SystemZ.
     #
     # Note: Clang allows IPO for -fPIC so this optimization is less effective.
-    # Older Clang may support -fno-semantic-interposition but it used local
-    # aliases to optimize global variables, which is incompatible with copy
-    # relocations due to -fno-pic.
+    # Clang 13 has a bug related to -fsanitize-coverage
+    # -fno-semantic-interposition (https://reviews.llvm.org/D117183).
     if ((CMAKE_COMPILER_IS_GNUCXX AND
          NOT (LLVM_NATIVE_ARCH STREQUAL "SystemZ" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 10.3))
-       OR (CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND CMAKE_CXX_COMPILER_VERSION GREATER_EQUAL 13))
+       OR (CMAKE_CXX_COMPILER_ID MATCHES "Clang" AND CMAKE_CXX_COMPILER_VERSION GREATER_EQUAL 14))
       add_flag_if_supported("-fno-semantic-interposition" FNO_SEMANTIC_INTERPOSITION)
     endif()
   endif()
diff -ruN llvm-project/llvm/CMakeLists.txt /home/dtrilla/git/novia/llvm-project/llvm/CMakeLists.txt
--- llvm-project/llvm/CMakeLists.txt	2023-05-24 11:35:47.004295657 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/CMakeLists.txt	2022-02-01 09:13:46.423669026 -0500
@@ -17,7 +17,7 @@
   set(LLVM_VERSION_MINOR 0)
 endif()
 if(NOT DEFINED LLVM_VERSION_PATCH)
-  set(LLVM_VERSION_PATCH 0)
+  set(LLVM_VERSION_PATCH 1)
 endif()
 if(NOT DEFINED LLVM_VERSION_SUFFIX)
   set(LLVM_VERSION_SUFFIX)
diff -ruN llvm-project/llvm/docs/ReleaseNotes.rst /home/dtrilla/git/novia/llvm-project/llvm/docs/ReleaseNotes.rst
--- llvm-project/llvm/docs/ReleaseNotes.rst	2023-05-24 11:35:47.068296348 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/docs/ReleaseNotes.rst	2022-02-01 09:13:46.423669026 -0500
@@ -5,11 +5,6 @@
 .. contents::
     :local:
 
-.. warning::
-   These are in-progress notes for the upcoming LLVM 13 release.
-   Release notes for previous releases can be found on
-   `the Download Page <https://releases.llvm.org/download.html>`_.
-
 
 Introduction
 ============
diff -ruN llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
--- llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h	2023-05-24 11:35:47.104296737 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h	2022-02-01 09:13:46.423669026 -0500
@@ -1098,28 +1098,10 @@
         continue;
       }
 
-      // The blockaddress constant expression is a weird special case, we can't
-      // generically walk its operands the way we do for all other constants.
-      if (BlockAddress *BA = dyn_cast<BlockAddress>(C)) {
-        // If we've already visited the function referred to by the block
-        // address, we don't need to revisit it.
-        if (Visited.count(BA->getFunction()))
-          continue;
-
-        // If all of the blockaddress' users are instructions within the
-        // referred to function, we don't need to insert a cycle.
-        if (llvm::all_of(BA->users(), [&](User *U) {
-              if (Instruction *I = dyn_cast<Instruction>(U))
-                return I->getFunction() == BA->getFunction();
-              return false;
-            }))
-          continue;
-
-        // Otherwise we should go visit the referred to function.
-        Visited.insert(BA->getFunction());
-        Worklist.push_back(BA->getFunction());
+      // blockaddresses are weird and don't participate in the call graph anyway,
+      // skip them.
+      if (isa<BlockAddress>(C))
         continue;
-      }
 
       for (Value *Op : C->operand_values())
         if (Visited.insert(cast<Constant>(Op)).second)
diff -ruN llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
--- llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h	2023-05-24 11:35:47.128296997 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h	2023-04-02 00:21:39.269078323 -0400
@@ -259,6 +259,11 @@
   /// like ADDC/SUBC, which indicate the carry result is always false.
   CARRY_FALSE,
 
+  // NFU
+  SET_LOAD_NFU,
+  EXEC_NFU,
+  POP_NFU,
+
   /// Carry-setting nodes for multiple precision addition and subtraction.
   /// These nodes take two operands of the same value type, and produce two
   /// results.  The first result is the normal add or sub result, the second
diff -ruN llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
--- llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h	2023-05-24 11:35:47.140297126 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h	2022-02-01 09:13:46.423669026 -0500
@@ -1922,9 +1922,7 @@
   /// Optional target hook that returns true if \p MBB is safe to outline from,
   /// and returns any target-specific information in \p Flags.
   virtual bool isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,
-                                      unsigned &Flags) const {
-    return true;
-  }
+                                      unsigned &Flags) const;
 
   /// Insert a custom frame for outlined functions.
   virtual void buildOutlinedFrame(MachineBasicBlock &MBB, MachineFunction &MF,
diff -ruN llvm-project/llvm/include/llvm/IR/Intrinsics.td /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/IR/Intrinsics.td
--- llvm-project/llvm/include/llvm/IR/Intrinsics.td	2023-05-24 11:35:47.176297514 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/IR/Intrinsics.td	2023-05-02 01:07:45.587732886 -0400
@@ -1761,6 +1761,19 @@
                                                             llvm_i32_ty],
                                                            [IntrNoMem, ImmArg<ArgIndex<2>>]>;
 
+//===------------------  NOVIA  --------------------------------------------===//
+def int_set_load_nfu : DefaultAttrsIntrinsic<[],
+                             [llvm_i32_ty,llvm_i32_ty,llvm_i32_ty,llvm_i32_ty],
+                             [IntrNoReturn, IntrNoMem, IntrHasSideEffects,ImmArg<ArgIndex<0>>, 
+                              ImmArg<ArgIndex<1>>, ImmArg<ArgIndex<2>>,ImmArg<ArgIndex<3>>]>;
+def int_exec_nfu : DefaultAttrsIntrinsic<[],[llvm_i32_ty,llvm_i32_ty],
+                             [IntrNoReturn,IntrHasSideEffects,ImmArg<ArgIndex<0>>,
+                              ImmArg<ArgIndex<1>>]>;
+def int_pop_nfu : DefaultAttrsIntrinsic<[llvm_any_ty],
+                             [llvm_i32_ty,llvm_i32_ty],
+                             [IntrNoMem, IntrHasSideEffects,ImmArg<ArgIndex<0>>,
+                              ImmArg<ArgIndex<1>>]>;
+
 //===----------------------------------------------------------------------===//
 
 //===----------------------------------------------------------------------===//
diff -ruN llvm-project/llvm/include/llvm/IR/Metadata.h /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/IR/Metadata.h
--- llvm-project/llvm/include/llvm/IR/Metadata.h	2023-05-24 11:35:47.188297644 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/IR/Metadata.h	2022-02-01 09:13:46.423669026 -0500
@@ -897,6 +897,7 @@
 class MDNode : public Metadata {
   friend class ReplaceableMetadataImpl;
   friend class LLVMContextImpl;
+  friend class DIArgList;
 
   unsigned NumOperands;
   unsigned NumUnresolved;
diff -ruN llvm-project/llvm/include/llvm/Support/Parallel.h /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/Support/Parallel.h
--- llvm-project/llvm/include/llvm/Support/Parallel.h	2023-05-24 11:35:47.220297990 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/Support/Parallel.h	2022-02-01 09:13:46.423669026 -0500
@@ -40,7 +40,10 @@
 
 public:
   explicit Latch(uint32_t Count = 0) : Count(Count) {}
-  ~Latch() { sync(); }
+  ~Latch() {
+    // Ensure at least that sync() was called.
+    assert(Count == 0);
+  }
 
   void inc() {
     std::lock_guard<std::mutex> lock(Mutex);
diff -ruN llvm-project/llvm/include/llvm/Target/TargetSelectionDAG.td /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/Target/TargetSelectionDAG.td
--- llvm-project/llvm/include/llvm/Target/TargetSelectionDAG.td	2023-05-24 11:35:47.228298075 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/include/llvm/Target/TargetSelectionDAG.td	2023-03-05 01:49:46.752355303 -0500
@@ -109,6 +109,9 @@
 def SDTUNDEF  : SDTypeProfile<1, 0, []>;                     // for 'undef'.
 def SDTUnaryOp  : SDTypeProfile<1, 1, []>;                   // for bitconvert.
 
+def NOVIAOp1 : SDTypeProfile<0, 2, [SDTCisInt<0>, SDTCisInt<1> ]>;
+def NOVIAOp2 : SDTypeProfile<1, 2, [SDTCisInt<0>, SDTCisInt<1>, SDTCisInt<2> ]>;
+
 def SDTIntBinOp : SDTypeProfile<1, 2, [     // add, and, or, xor, udiv, etc.
   SDTCisSameAs<0, 1>, SDTCisSameAs<0, 2>, SDTCisInt<0>
 ]>;
@@ -453,6 +456,8 @@
 def vecreduce_umin  : SDNode<"ISD::VECREDUCE_UMIN", SDTVecReduce>;
 def vecreduce_fadd  : SDNode<"ISD::VECREDUCE_FADD", SDTFPVecReduce>;
 
+def exec_nfu   : SDNode<"ISD::EXEC_NFU"   , NOVIAOp1>;
+def pop_nfu    : SDNode<"ISD::POP_NFU"    , NOVIAOp2>;
 def fadd       : SDNode<"ISD::FADD"       , SDTFPBinOp, [SDNPCommutative]>;
 def fsub       : SDNode<"ISD::FSUB"       , SDTFPBinOp>;
 def fmul       : SDNode<"ISD::FMUL"       , SDTFPBinOp, [SDNPCommutative]>;
diff -ruN llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp
--- llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp	2023-05-24 11:35:47.244298248 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Analysis/AliasAnalysis.cpp	2022-02-01 09:13:46.423669026 -0500
@@ -697,14 +697,16 @@
   case Instruction::AtomicRMW:
     return getModRefInfo((const AtomicRMWInst *)I, Loc, AAQIP);
   case Instruction::Call:
-    return getModRefInfo((const CallInst *)I, Loc, AAQIP);
+  case Instruction::CallBr:
   case Instruction::Invoke:
-    return getModRefInfo((const InvokeInst *)I, Loc, AAQIP);
+    return getModRefInfo((const CallBase *)I, Loc, AAQIP);
   case Instruction::CatchPad:
     return getModRefInfo((const CatchPadInst *)I, Loc, AAQIP);
   case Instruction::CatchRet:
     return getModRefInfo((const CatchReturnInst *)I, Loc, AAQIP);
   default:
+    assert(!I->mayReadOrWriteMemory() &&
+           "Unhandled memory access instruction!");
     return ModRefInfo::NoModRef;
   }
 }
diff -ruN llvm-project/llvm/lib/Analysis/InlineCost.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Analysis/InlineCost.cpp
--- llvm-project/llvm/lib/Analysis/InlineCost.cpp	2023-05-24 11:35:47.252298335 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Analysis/InlineCost.cpp	2022-02-01 09:13:46.423669026 -0500
@@ -354,6 +354,7 @@
   bool simplifyCallSite(Function *F, CallBase &Call);
   template <typename Callable>
   bool simplifyInstruction(Instruction &I, Callable Evaluate);
+  bool simplifyIntrinsicCallIsConstant(CallBase &CB);
   ConstantInt *stripAndComputeInBoundsConstantOffsets(Value *&V);
 
   /// Return true if the given argument to the function being considered for
@@ -1471,6 +1472,27 @@
   return true;
 }
 
+/// Try to simplify a call to llvm.is.constant.
+///
+/// Duplicate the argument checking from CallAnalyzer::simplifyCallSite since
+/// we expect calls of this specific intrinsic to be infrequent.
+///
+/// FIXME: Given that we know CB's parent (F) caller
+/// (CandidateCall->getParent()->getParent()), we might be able to determine
+/// whether inlining F into F's caller would change how the call to
+/// llvm.is.constant would evaluate.
+bool CallAnalyzer::simplifyIntrinsicCallIsConstant(CallBase &CB) {
+  Value *Arg = CB.getArgOperand(0);
+  auto *C = dyn_cast<Constant>(Arg);
+
+  if (!C)
+    C = dyn_cast_or_null<Constant>(SimplifiedValues.lookup(Arg));
+
+  Type *RT = CB.getFunctionType()->getReturnType();
+  SimplifiedValues[&CB] = ConstantInt::get(RT, C ? 1 : 0);
+  return true;
+}
+
 bool CallAnalyzer::visitBitCast(BitCastInst &I) {
   // Propagate constants through bitcasts.
   if (simplifyInstruction(I, [&](SmallVectorImpl<Constant *> &COps) {
@@ -2091,6 +2113,8 @@
       if (auto *SROAArg = getSROAArgForValueOrNull(II->getOperand(0)))
         SROAArgValues[II] = SROAArg;
       return true;
+    case Intrinsic::is_constant:
+      return simplifyIntrinsicCallIsConstant(Call);
     }
   }
 
diff -ruN llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp
--- llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp	2023-05-24 11:35:47.296298809 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/DwarfEHPrepare.cpp	2022-02-01 09:13:46.423669026 -0500
@@ -318,6 +318,11 @@
     return prepareDwarfEH(OptLevel, RewindFunction, F, TLI, DT, TTI);
   }
 
+  bool doFinalization(Module &M) override {
+    RewindFunction = nullptr;
+    return false;
+  }
+
   void getAnalysisUsage(AnalysisUsage &AU) const override {
     AU.addRequired<TargetPassConfig>();
     AU.addRequired<TargetTransformInfoWrapperPass>();
diff -ruN llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp
--- llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp	2023-05-24 11:35:47.332299199 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -15,6 +15,7 @@
 #include "llvm/ADT/ArrayRef.h"
 #include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/IndexedMap.h"
+#include "llvm/ADT/MapVector.h"
 #include "llvm/ADT/SmallSet.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/SparseSet.h"
@@ -432,7 +433,7 @@
   // every definition of it, meaning we can switch all the DBG_VALUEs over
   // to just reference the stack slot.
   SmallVectorImpl<MachineOperand *> &LRIDbgOperands = LiveDbgValueMap[VirtReg];
-  SmallDenseMap<MachineInstr *, SmallVector<const MachineOperand *>>
+  SmallMapVector<MachineInstr *, SmallVector<const MachineOperand *>, 2>
       SpilledOperandsMap;
   for (MachineOperand *MO : LRIDbgOperands)
     SpilledOperandsMap[MO->getParent()].push_back(MO);
diff -ruN llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
--- llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp	2023-05-24 11:35:47.344299328 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp	2023-05-02 00:46:09.152701906 -0400
@@ -266,7 +266,7 @@
 
       // Skip handle nodes as they can't usefully be combined and confuse the
       // zero-use deletion strategy.
-      if (N->getOpcode() == ISD::HANDLENODE)
+      if (N->getOpcode() == ISD::HANDLENODE) 
         return;
 
       ConsiderForPruning(N);
diff -ruN llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
--- llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp	2023-05-24 11:35:47.344299328 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp	2023-04-02 00:20:13.132036107 -0400
@@ -1109,6 +1109,11 @@
     // They'll be converted to Copy(To/From)Reg.
     Action = TargetLowering::Legal;
     break;
+  case ISD::EXEC_NFU:
+  case ISD::POP_NFU:
+  case ISD::SET_LOAD_NFU:
+    Action = TargetLowering::Legal;
+    break;
   case ISD::UBSANTRAP:
     Action = TLI.getOperationAction(Node->getOpcode(), Node->getValueType(0));
     if (Action == TargetLowering::Expand) {
diff -ruN llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
--- llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2023-05-24 11:35:47.356299457 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp	2023-05-01 16:26:23.389057494 -0400
@@ -5808,6 +5808,24 @@
              DAG.getVScale(getCurSDLoc(), VT, APInt(VT.getSizeInBits(), 1)));
     return;
   }
+  /*case Intrinsic::exec_nfu:{
+    //EVT VT = TLI.getValueType(DAG.getDataLayout(), I.getType());
+    //SDValue Imm1 = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(0))->getSExtValue(), sdl, MVT::i32);
+    //SDValue Imm2 = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(1))->getSExtValue(), sdl, MVT::i32);
+    //setValue(&I,Res);
+    SDVTList nodeTys = DAG.getVTList(MVT::Other);
+    SDValue Ops[2];
+    //Ops[0] = getRoot();
+    //Ops[1] = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(0))->getSExtValue(),sdl,MVT::i8);
+    //Ops[2] = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(1))->getSExtValue(),sdl,MVT::i8);
+    Ops[0] = getValue(I.getOperand(0));
+    Ops[1] = getValue(I.getOperand(1));
+    Res = DAG.getNode(ISD::EXEC_NFU,sdl,nodeTys,Ops);
+    SDValue TokenFactor = DAG.getNode(ISD::TokenFactor, sdl, MVT::Other,{Res});
+    setValue(&I,Res);
+    DAG.setRoot(TokenFactor);
+    return;
+    }*/
   case Intrinsic::vastart:  visitVAStart(I); return;
   case Intrinsic::vaend:    visitVAEnd(I); return;
   case Intrinsic::vacopy:   visitVACopy(I); return;
diff -ruN llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp
--- llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp	2023-05-24 11:35:47.360299500 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp	2023-02-26 19:22:15.510389327 -0500
@@ -414,6 +414,8 @@
     return "call_setup";
   case ISD::PREALLOCATED_ARG:
     return "call_alloc";
+  case ISD::EXEC_NFU:                   return "exec_nfu";
+  case ISD::POP_NFU:                    return "pop_nfu";
 
   // Floating point environment manipulation
   case ISD::FLT_ROUNDS_:                return "flt_rounds";
diff -ruN llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp
--- llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp	2023-05-24 11:35:47.368299586 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -1417,3 +1417,16 @@
 }
 
 TargetInstrInfo::PipelinerLoopInfo::~PipelinerLoopInfo() {}
+
+bool TargetInstrInfo::isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,
+                                             unsigned &Flags) const {
+  // Some instrumentations create special TargetOpcode at the start which
+  // expands to special code sequences which must be present.
+  auto First = MBB.getFirstNonDebugInstr();
+  if (First != MBB.end() &&
+      (First->getOpcode() == TargetOpcode::FENTRY_CALL ||
+       First->getOpcode() == TargetOpcode::PATCHABLE_FUNCTION_ENTER))
+    return false;
+
+  return true;
+}
diff -ruN llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp
--- llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp	2023-05-24 11:35:47.368299586 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp	2023-04-02 00:21:06.308680346 -0400
@@ -755,6 +755,9 @@
       setIndexedMaskedStoreAction(IM, VT, Expand);
     }
 
+    setOperationAction(ISD::EXEC_NFU,VT,Legal);
+    setOperationAction(ISD::SET_LOAD_NFU,VT,Legal);
+    setOperationAction(ISD::POP_NFU,VT,Legal);
     // Most backends expect to see the node which just returns the value loaded.
     setOperationAction(ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS, VT, Expand);
 
diff -ruN llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp
--- llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp	2023-05-24 11:35:47.412300062 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -1592,6 +1592,12 @@
   assert((!New || isa<ValueAsMetadata>(New)) &&
          "DIArgList must be passed a ValueAsMetadata");
   untrack();
+  bool Uniq = isUniqued();
+  if (Uniq) {
+    // We need to update the uniqueness once the Args are updated since they
+    // form the key to the DIArgLists store.
+    eraseFromStore();
+  }
   ValueAsMetadata *NewVM = cast_or_null<ValueAsMetadata>(New);
   for (ValueAsMetadata *&VM : Args) {
     if (&VM == OldVMPtr) {
@@ -1601,6 +1607,10 @@
         VM = ValueAsMetadata::get(UndefValue::get(VM->getValue()->getType()));
     }
   }
+  if (Uniq) {
+    if (uniquify() != this)
+      storeDistinctInContext();
+  }
   track();
 }
 void DIArgList::track() {
diff -ruN llvm-project/llvm/lib/IR/LLVMContextImpl.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp
--- llvm-project/llvm/lib/IR/LLVMContextImpl.cpp	2023-05-24 11:35:47.416300104 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -55,8 +55,15 @@
 
   // Drop references for MDNodes.  Do this before Values get deleted to avoid
   // unnecessary RAUW when nodes are still unresolved.
-  for (auto *I : DistinctMDNodes)
+  for (auto *I : DistinctMDNodes) {
+    // We may have DIArgList that were uniqued, and as it has a custom
+    // implementation of dropAllReferences, it needs to be explicitly invoked.
+    if (auto *AL = dyn_cast<DIArgList>(I)) {
+      AL->dropAllReferences();
+      continue;
+    }
     I->dropAllReferences();
+  }
 #define HANDLE_MDNODE_LEAF_UNIQUABLE(CLASS)                                    \
   for (auto *I : CLASS##s)                                                     \
     I->dropAllReferences();
diff -ruN llvm-project/llvm/lib/IR/LLVMContextImpl.h /home/dtrilla/git/novia/llvm-project/llvm/lib/IR/LLVMContextImpl.h
--- llvm-project/llvm/lib/IR/LLVMContextImpl.h	2023-05-24 11:35:47.416300104 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/IR/LLVMContextImpl.h	2022-02-01 09:13:46.427669067 -0500
@@ -391,8 +391,9 @@
         IsUnsigned(N->isUnsigned()) {}
 
   bool isKeyOf(const DIEnumerator *RHS) const {
-    return APInt::isSameValue(Value, RHS->getValue()) &&
-           IsUnsigned == RHS->isUnsigned() && Name == RHS->getRawName();
+    return Value.getBitWidth() == RHS->getValue().getBitWidth() &&
+           Value == RHS->getValue() && IsUnsigned == RHS->isUnsigned() &&
+           Name == RHS->getRawName();
   }
 
   unsigned getHashValue() const { return hash_combine(Value, Name); }
diff -ruN llvm-project/llvm/lib/MC/MCParser/ELFAsmParser.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/MC/MCParser/ELFAsmParser.cpp
--- llvm-project/llvm/lib/MC/MCParser/ELFAsmParser.cpp	2023-05-24 11:35:47.432300277 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/MC/MCParser/ELFAsmParser.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -502,6 +502,23 @@
   return SectionName.startswith(Prefix) || SectionName == Prefix.drop_back();
 }
 
+static bool allowSectionTypeMismatch(const Triple &TT, StringRef SectionName,
+                                     unsigned Type) {
+  if (TT.getArch() == Triple::x86_64) {
+    // x86-64 psABI names SHT_X86_64_UNWIND as the canonical type for .eh_frame,
+    // but GNU as emits SHT_PROGBITS .eh_frame for .cfi_* directives. Don't
+    // error for SHT_PROGBITS .eh_frame
+    return SectionName == ".eh_frame" && Type == ELF::SHT_PROGBITS;
+  }
+  if (TT.isMIPS()) {
+    // MIPS .debug_* sections should have SHT_MIPS_DWARF section type to
+    // distinguish among sections contain DWARF and ECOFF debug formats,
+    // but in assembly files these sections have SHT_PROGBITS type.
+    return hasPrefix(SectionName, ".debug_") && Type == ELF::SHT_PROGBITS;
+  }
+  return false;
+}
+
 bool ELFAsmParser::ParseSectionArguments(bool IsPush, SMLoc loc) {
   StringRef SectionName;
 
@@ -659,16 +676,14 @@
       getContext().getELFSection(SectionName, Type, Flags, Size, GroupName,
                                  IsComdat, UniqueID, LinkedToSym);
   getStreamer().SwitchSection(Section, Subsection);
-  // x86-64 psABI names SHT_X86_64_UNWIND as the canonical type for .eh_frame,
-  // but GNU as emits SHT_PROGBITS .eh_frame for .cfi_* directives. Don't error
-  // for SHT_PROGBITS .eh_frame
-  if (Section->getType() != Type &&
-      !(SectionName == ".eh_frame" && Type == ELF::SHT_PROGBITS))
-    Error(loc, "changed section type for " + SectionName + ", expected: 0x" +
-                   utohexstr(Section->getType()));
   // Check that flags are used consistently. However, the GNU assembler permits
   // to leave out in subsequent uses of the same sections; for compatibility,
   // do likewise.
+  if (!TypeName.empty() && Section->getType() != Type &&
+      !allowSectionTypeMismatch(getContext().getTargetTriple(), SectionName,
+                                Type))
+    Error(loc, "changed section type for " + SectionName + ", expected: 0x" +
+                   utohexstr(Section->getType()));
   if ((extraFlags || Size || !TypeName.empty()) && Section->getFlags() != Flags)
     Error(loc, "changed section flags for " + SectionName + ", expected: 0x" +
                    utohexstr(Section->getFlags()));
diff -ruN llvm-project/llvm/lib/Support/Parallel.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Support/Parallel.cpp
--- llvm-project/llvm/lib/Support/Parallel.cpp	2023-05-24 11:35:47.464300623 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Support/Parallel.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -151,7 +151,12 @@
 // lock, only allow the first TaskGroup to run tasks parallelly. In the scenario
 // of nested parallel_for_each(), only the outermost one runs parallelly.
 TaskGroup::TaskGroup() : Parallel(TaskGroupInstances++ == 0) {}
-TaskGroup::~TaskGroup() { --TaskGroupInstances; }
+TaskGroup::~TaskGroup() {
+  // We must ensure that all the workloads have finished before decrementing the
+  // instances count.
+  L.sync();
+  --TaskGroupInstances;
+}
 
 void TaskGroup::spawn(std::function<void()> F) {
   if (Parallel) {
diff -ruN llvm-project/llvm/lib/Support/Unix/Memory.inc /home/dtrilla/git/novia/llvm-project/llvm/lib/Support/Unix/Memory.inc
--- llvm-project/llvm/lib/Support/Unix/Memory.inc	2023-05-24 11:35:47.468300666 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Support/Unix/Memory.inc	2022-02-01 09:13:46.427669067 -0500
@@ -29,14 +29,6 @@
 #include <zircon/syscalls.h>
 #endif
 
-#if defined(__mips__)
-#  if defined(__OpenBSD__)
-#    include <mips64/sysarch.h>
-#  elif !defined(__FreeBSD__)
-#    include <sys/cachectl.h>
-#  endif
-#endif
-
 #if defined(__APPLE__)
 extern "C" void sys_icache_invalidate(const void *Addr, size_t len);
 #else
diff -ruN llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp
--- llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp	2023-05-24 11:35:47.480300795 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -1049,6 +1049,7 @@
   case AArch64::MOVaddrEXT: {
     // Expand into ADRP + ADD.
     Register DstReg = MI.getOperand(0).getReg();
+    assert(DstReg != AArch64::XZR);
     MachineInstrBuilder MIB1 =
         BuildMI(MBB, MBBI, MI.getDebugLoc(), TII->get(AArch64::ADRP), DstReg)
             .add(MI.getOperand(1));
diff -ruN llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp
--- llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp	2023-05-24 11:35:47.484300839 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp	2022-02-01 09:13:46.427669067 -0500
@@ -6923,6 +6923,8 @@
 
 bool AArch64InstrInfo::isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,
                                               unsigned &Flags) const {
+  if (!TargetInstrInfo::isMBBSafeToOutlineFrom(MBB, Flags))
+    return false;
   // Check if LR is available through all of the MBB. If it's not, then set
   // a flag.
   assert(MBB.getParent()->getRegInfo().tracksLiveness() &&
diff -ruN llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.td
--- llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.td	2023-05-24 11:35:47.488300883 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.td	2022-02-01 09:13:46.431669108 -0500
@@ -673,40 +673,40 @@
 // removed, along with the AArch64Wrapper node.
 
 let AddedComplexity = 10 in
-def LOADgot : Pseudo<(outs GPR64:$dst), (ins i64imm:$addr),
-                     [(set GPR64:$dst, (AArch64LOADgot tglobaladdr:$addr))]>,
+def LOADgot : Pseudo<(outs GPR64common:$dst), (ins i64imm:$addr),
+                     [(set GPR64common:$dst, (AArch64LOADgot tglobaladdr:$addr))]>,
               Sched<[WriteLDAdr]>;
 
 // The MOVaddr instruction should match only when the add is not folded
 // into a load or store address.
 def MOVaddr
-    : Pseudo<(outs GPR64:$dst), (ins i64imm:$hi, i64imm:$low),
-             [(set GPR64:$dst, (AArch64addlow (AArch64adrp tglobaladdr:$hi),
+    : Pseudo<(outs GPR64common:$dst), (ins i64imm:$hi, i64imm:$low),
+             [(set GPR64common:$dst, (AArch64addlow (AArch64adrp tglobaladdr:$hi),
                                             tglobaladdr:$low))]>,
       Sched<[WriteAdrAdr]>;
 def MOVaddrJT
-    : Pseudo<(outs GPR64:$dst), (ins i64imm:$hi, i64imm:$low),
-             [(set GPR64:$dst, (AArch64addlow (AArch64adrp tjumptable:$hi),
+    : Pseudo<(outs GPR64common:$dst), (ins i64imm:$hi, i64imm:$low),
+             [(set GPR64common:$dst, (AArch64addlow (AArch64adrp tjumptable:$hi),
                                              tjumptable:$low))]>,
       Sched<[WriteAdrAdr]>;
 def MOVaddrCP
-    : Pseudo<(outs GPR64:$dst), (ins i64imm:$hi, i64imm:$low),
-             [(set GPR64:$dst, (AArch64addlow (AArch64adrp tconstpool:$hi),
+    : Pseudo<(outs GPR64common:$dst), (ins i64imm:$hi, i64imm:$low),
+             [(set GPR64common:$dst, (AArch64addlow (AArch64adrp tconstpool:$hi),
                                              tconstpool:$low))]>,
       Sched<[WriteAdrAdr]>;
 def MOVaddrBA
-    : Pseudo<(outs GPR64:$dst), (ins i64imm:$hi, i64imm:$low),
-             [(set GPR64:$dst, (AArch64addlow (AArch64adrp tblockaddress:$hi),
+    : Pseudo<(outs GPR64common:$dst), (ins i64imm:$hi, i64imm:$low),
+             [(set GPR64common:$dst, (AArch64addlow (AArch64adrp tblockaddress:$hi),
                                              tblockaddress:$low))]>,
       Sched<[WriteAdrAdr]>;
 def MOVaddrTLS
-    : Pseudo<(outs GPR64:$dst), (ins i64imm:$hi, i64imm:$low),
-             [(set GPR64:$dst, (AArch64addlow (AArch64adrp tglobaltlsaddr:$hi),
+    : Pseudo<(outs GPR64common:$dst), (ins i64imm:$hi, i64imm:$low),
+             [(set GPR64common:$dst, (AArch64addlow (AArch64adrp tglobaltlsaddr:$hi),
                                             tglobaltlsaddr:$low))]>,
       Sched<[WriteAdrAdr]>;
 def MOVaddrEXT
-    : Pseudo<(outs GPR64:$dst), (ins i64imm:$hi, i64imm:$low),
-             [(set GPR64:$dst, (AArch64addlow (AArch64adrp texternalsym:$hi),
+    : Pseudo<(outs GPR64common:$dst), (ins i64imm:$hi, i64imm:$low),
+             [(set GPR64common:$dst, (AArch64addlow (AArch64adrp texternalsym:$hi),
                                             texternalsym:$low))]>,
       Sched<[WriteAdrAdr]>;
 // Normally AArch64addlow either gets folded into a following ldr/str,
@@ -714,8 +714,8 @@
 // might appear without either of them, so allow lowering it into a plain
 // add.
 def ADDlowTLS
-    : Pseudo<(outs GPR64:$dst), (ins GPR64:$src, i64imm:$low),
-             [(set GPR64:$dst, (AArch64addlow GPR64:$src,
+    : Pseudo<(outs GPR64sp:$dst), (ins GPR64sp:$src, i64imm:$low),
+             [(set GPR64sp:$dst, (AArch64addlow GPR64sp:$src,
                                             tglobaltlsaddr:$low))]>,
       Sched<[WriteAdr]>;
 
diff -ruN llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp
--- llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp	2023-05-24 11:35:47.504301055 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -13,6 +13,8 @@
 
 #include "AArch64RegisterBankInfo.h"
 #include "AArch64InstrInfo.h"
+#include "AArch64RegisterInfo.h"
+#include "MCTargetDesc/AArch64MCTargetDesc.h"
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/CodeGen/GlobalISel/RegisterBank.h"
@@ -271,6 +273,7 @@
   case AArch64::WSeqPairsClassRegClassID:
   case AArch64::XSeqPairsClassRegClassID:
   case AArch64::MatrixIndexGPR32_12_15RegClassID:
+  case AArch64::GPR64_with_sub_32_in_MatrixIndexGPR32_12_15RegClassID:
     return getRegBank(AArch64::GPRRegBankID);
   case AArch64::CCRRegClassID:
     return getRegBank(AArch64::CCRegBankID);
diff -ruN llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp
--- llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp	2023-05-24 11:35:47.544301486 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/AMDGPU/SILoadStoreOptimizer.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -2048,7 +2048,7 @@
     // adjacent to each other in the list, which will make it easier to find
     // matches.
     MergeList.sort(
-        [] (const CombineInfo &A, CombineInfo &B) {
+        [] (const CombineInfo &A, const CombineInfo &B) {
           return A.Offset < B.Offset;
         });
     ++I;
diff -ruN llvm-project/llvm/lib/Target/ARM/ARMCallLowering.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMCallLowering.cpp
--- llvm-project/llvm/lib/Target/ARM/ARMCallLowering.cpp	2023-05-24 11:35:47.560301659 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMCallLowering.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -525,7 +525,7 @@
 
   MIRBuilder.buildInstr(ARM::ADJCALLSTACKUP)
       .addImm(ArgAssigner.StackOffset)
-      .addImm(0)
+      .addImm(-1ULL)
       .add(predOps(ARMCC::AL));
 
   return true;
diff -ruN llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp
--- llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp	2023-05-24 11:35:47.564301702 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -2022,7 +2022,7 @@
   unsigned AdjStackUp = TII.getCallFrameDestroyOpcode();
   AddOptionalDefs(BuildMI(*FuncInfo.MBB, FuncInfo.InsertPt, DbgLoc,
                           TII.get(AdjStackUp))
-                  .addImm(NumBytes).addImm(0));
+                  .addImm(NumBytes).addImm(-1ULL));
 
   // Now the return value.
   if (RetVT != MVT::isVoid) {
diff -ruN llvm-project/llvm/lib/Target/ARM/ARMInstrThumb2.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMInstrThumb2.td
--- llvm-project/llvm/lib/Target/ARM/ARMInstrThumb2.td	2023-05-24 11:35:47.576301831 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMInstrThumb2.td	2022-02-01 09:13:46.431669108 -0500
@@ -4670,6 +4670,9 @@
 }
 
 
+// Reading thread pointer from coprocessor register
+def : T2Pat<(ARMthread_pointer), (t2MRC 15, 0, 13, 0, 3)>,
+      Requires<[IsThumb2, IsReadTPHard]>;
 
 //===----------------------------------------------------------------------===//
 // ARMv8.1 Privilege Access Never extension
diff -ruN llvm-project/llvm/lib/Target/ARM/ARMInstrThumb.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMInstrThumb.td
--- llvm-project/llvm/lib/Target/ARM/ARMInstrThumb.td	2023-05-24 11:35:47.576301831 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMInstrThumb.td	2022-02-01 09:13:46.431669108 -0500
@@ -1520,6 +1520,7 @@
 let isCall = 1, Defs = [R0, R12, LR, CPSR], Uses = [SP] in
 def tTPsoft : tPseudoInst<(outs), (ins), 4, IIC_Br,
                           [(set R0, ARMthread_pointer)]>,
+                          Requires<[IsThumb, IsReadTPSoft]>,
                           Sched<[WriteBr]>;
 
 //===----------------------------------------------------------------------===//
diff -ruN llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp
--- llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp	2023-05-24 11:35:47.564301702 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -79,6 +79,10 @@
 
   void Select(SDNode *N) override;
 
+  /// Return true as some complex patterns, like those that call
+  /// canExtractShiftFromMul can modify the DAG inplace.
+  bool ComplexPatternFuncMutatesDAG() const override { return true; }
+
   bool hasNoVMLxHazardUse(SDNode *N) const;
   bool isShifterOpProfitable(const SDValue &Shift,
                              ARM_AM::ShiftOpc ShOpcVal, unsigned ShAmt);
diff -ruN llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp
--- llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp	2023-05-24 11:35:47.656302695 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -1027,12 +1027,13 @@
     }
 
     SDNode *Rdhwr =
-        CurDAG->getMachineNode(RdhwrOpc, DL, Node->getValueType(0),
+        CurDAG->getMachineNode(RdhwrOpc, DL, Node->getValueType(0), MVT::Glue,
                                CurDAG->getRegister(Mips::HWR29, MVT::i32),
                                CurDAG->getTargetConstant(0, DL, MVT::i32));
     SDValue Chain = CurDAG->getCopyToReg(CurDAG->getEntryNode(), DL, DestReg,
-                                         SDValue(Rdhwr, 0));
-    SDValue ResNode = CurDAG->getCopyFromReg(Chain, DL, DestReg, PtrVT);
+                                         SDValue(Rdhwr, 0), SDValue(Rdhwr, 1));
+    SDValue ResNode = CurDAG->getCopyFromReg(Chain, DL, DestReg, PtrVT,
+                                             Chain.getValue(1));
     ReplaceNode(Node, ResNode.getNode());
     return true;
   }
diff -ruN llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp
--- llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp	2023-05-24 11:35:47.668302824 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -1576,6 +1576,16 @@
     std::swap(Operands[2], Operands[1]);
   }
 
+  // Handle base mnemonic for atomic loads where the EH bit is zero.
+  if (Name == "lqarx" || Name == "ldarx" || Name == "lwarx" ||
+      Name == "lharx" || Name == "lbarx") {
+    if (Operands.size() != 5)
+      return false;
+    PPCOperand &EHOp = (PPCOperand &)*Operands[4];
+    if (EHOp.isU1Imm() && EHOp.getImm() == 0)
+      Operands.pop_back();
+  }
+
   return false;
 }
 
@@ -1745,7 +1755,7 @@
   }
 
   PPCOperand &Op = static_cast<PPCOperand &>(AsmOp);
-  if (Op.isImm() && Op.getImm() == ImmVal)
+  if (Op.isU3Imm() && Op.getImm() == ImmVal)
     return Match_Success;
 
   return Match_InvalidOperand;
diff -ruN llvm-project/llvm/lib/Target/RISCV/RISCVInstrFormats.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrFormats.td
--- llvm-project/llvm/lib/Target/RISCV/RISCVInstrFormats.td	2023-05-24 11:35:47.696303128 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrFormats.td	2023-05-02 01:09:07.708631626 -0400
@@ -48,6 +48,7 @@
 def InstFormatCB     : InstFormat<15>;
 def InstFormatCJ     : InstFormat<16>;
 def InstFormatOther  : InstFormat<17>;
+def InstFormatNFU    : InstFormat<18>;
 
 class RISCVVConstraint<bits<3> val> {
   bits<3> Value = val;
@@ -132,6 +133,7 @@
 def OPC_JALR      : RISCVOpcode<0b1100111>;
 def OPC_JAL       : RISCVOpcode<0b1101111>;
 def OPC_SYSTEM    : RISCVOpcode<0b1110011>;
+def OPC_NFU       : RISCVOpcode<0b1011011>;
 
 class RVInst<dag outs, dag ins, string opcodestr, string argstr,
              list<dag> pattern, InstFormat format>
@@ -217,6 +219,33 @@
   let isAsmParserOnly = 1;
 }
 
+class NFUInstA<bits<3> funct, RISCVOpcode opcode, dag outs, dag ins, string opcodestr, string argstr >
+: RVInst<outs,ins,opcodestr,argstr,[],InstFormatNFU>{
+  bits<5> mask1;
+  bits<5> mask2;
+  bits<5> mask3;
+  bits<5> nfu;
+
+  let Inst{31-30} = 0;
+  let Inst{29-25} = mask3;
+  let Inst{24-20} = mask2;
+  let Inst{19-15} = mask1;
+  let Inst{14-10} = nfu;
+  let Inst{9-7} = funct;
+  let Opcode = opcode.Value;
+}
+
+class NFUInstB<bits<3> funct, RISCVOpcode opcode, dag outs, dag ins, string opcodestr, string argstr >
+      : RVInst<outs,ins, opcodestr, argstr, [], InstFormatNFU> {
+  bits<5> rd;
+  bits<5> nfu;
+
+  let Inst{31-20} = 0;
+  let Inst{19-15} = rd;
+  let Inst{14-10} = nfu;
+  let Inst{9-7} = funct;
+  let Opcode = opcode.Value;
+}
 // Instruction formats are listed in the order they appear in the RISC-V
 // instruction set manual (R, I, S, B, U, J) with sub-formats (e.g. RVInstR4,
 // RVInstRAtomic) sorted alphabetically.
diff -ruN llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp
--- llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp	2023-05-24 11:35:47.696303128 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp	2022-02-01 09:13:46.431669108 -0500
@@ -999,7 +999,7 @@
 bool RISCVInstrInfo::isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,
                                             unsigned &Flags) const {
   // More accurate safety checking is done in getOutliningCandidateInfo.
-  return true;
+  return TargetInstrInfo::isMBBSafeToOutlineFrom(MBB, Flags);
 }
 
 // Enum values indicating how an outlined call should be constructed.
diff -ruN llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.td
--- llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.td	2023-05-24 11:35:47.696303128 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.td	2023-05-02 01:05:05.045894874 -0400
@@ -471,6 +471,15 @@
            Sched<[WriteJalr, ReadJalr]>;
 } // hasSideEffects = 0, mayLoad = 0, mayStore = 0
 
+let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {
+def SET_LOAD_NFU : NFUInstA<0b000, OPC_NFU, (outs), (ins uimm5:$nfu, uimm5:$mask1, uimm5:$mask2, uimm5:$mask3),
+                      "set_load_nfu", "nfu$nfu, $mask1, $mask2, $mask3">,Sched<[]>;
+def EXEC_NFU : NFUInstB<0b001, OPC_NFU, (outs), (ins uimm5:$nfu, uimm5:$rd),
+                      "exec_nfu", "nfu$nfu, $rd">,Sched<[]>;
+def POP_NFU : NFUInstB<0b010, OPC_NFU, (outs GPR:$dst), (ins uimm5:$nfu, uimm5:$rd),
+                      "pop_nfu", "$rd, nfu$nfu, $rd">,Sched<[]>;
+}
+
 def BEQ  : BranchCC_rri<0b000, "beq">;
 def BNE  : BranchCC_rri<0b001, "bne">;
 def BLT  : BranchCC_rri<0b100, "blt">;
diff -ruN llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td
--- llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td	2023-05-24 11:35:47.700303170 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td	2023-03-11 14:16:50.465617124 -0500
@@ -4602,6 +4602,12 @@
   defm : VPatUnaryV_V_AnyMask<"int_riscv_vcompress", "PseudoVCOMPRESS", AllFloatVectors>;
 } // Predicates = [HasStdExtV, HasStdExtF]
 
+
+//===----------------------------------------------------------------------===//
+// 17.6.  NFU Instructions---------------------------------------------------===//
+  //def : Pat<(int_exec_nfu imm:$imm1, imm:$imm2),(EXEC_NFU uimm5:$imm1, uimm5:$imm2)>;
+  //def : Pat<(int_exec_nfu uimm5:$nfu),(EXEC_NFU uimm5:$nfu)>;
+
 // Include the non-intrinsic ISel patterns
 include "RISCVInstrInfoVSDPatterns.td"
 include "RISCVInstrInfoVVLPatterns.td"
diff -ruN llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
--- llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp	2023-05-24 11:35:47.692303084 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp	2023-05-02 09:56:57.194443370 -0400
@@ -451,6 +451,12 @@
   MVT VT = Node->getSimpleValueType(0);
 
   switch (Opcode) {
+  case ISD::EXEC_NFU: {
+    SDValue Op1 = Node->getOperand(0);
+    SDValue Op2 = Node->getOperand(1);
+    ReplaceNode(Node, CurDAG->getMachineNode(RISCV::EXEC_NFU,DL,MVT::Other,{Op1,Op2}));
+    return;
+  }
   case ISD::Constant: {
     auto *ConstNode = cast<ConstantSDNode>(Node);
     if (VT == XLenVT && ConstNode->isNullValue()) {
@@ -629,6 +635,26 @@
       // By default we do not custom select any intrinsic.
     default:
       break;
+    case Intrinsic::exec_nfu: {
+       /*         
+      SDValue Op1 = Node->getOperand(1);
+      SDValue Op2 = Node->getOperand(2);
+      ReplaceNode(Node,CurDAG->getMachineNode(ISD::EXEC_NFU,DL,MVT::i32,Op1,Op2));
+      return;*/
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      assert(C1 && C2 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::EXEC_NFU,DL,MVT::Other,{Imm1Node,Imm2Node}));
+    }
+      
     case Intrinsic::riscv_vmsgeu:
     case Intrinsic::riscv_vmsge: {
       SDValue Src1 = Node->getOperand(1);
@@ -837,7 +863,22 @@
       // By default we do not custom select any intrinsic.
     default:
       break;
-
+    case Intrinsic::pop_nfu: {
+      EVT RetTy = Node->getValueType(0);
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      assert(C1 && C2 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::POP_NFU,DL,{RetTy,MVT::Other},{Imm1Node,Imm2Node,Node->getOperand(0)}));
+      return;
+    }
     case Intrinsic::riscv_vsetvli:
     case Intrinsic::riscv_vsetvlimax: {
       if (!Subtarget->hasStdExtV())
@@ -1093,6 +1134,50 @@
   case ISD::INTRINSIC_VOID: {
     unsigned IntNo = cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();
     switch (IntNo) {
+    case Intrinsic::exec_nfu: {
+       /*         
+      SDValue Op1 = Node->getOperand(1);
+      SDValue Op2 = Node->getOperand(2);
+      ReplaceNode(Node,CurDAG->getMachineNode(ISD::EXEC_NFU,DL,MVT::i32,Op1,Op2));
+      return;*/
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      assert(C1 && C2 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::EXEC_NFU,DL,MVT::Other,{Imm1Node,Imm2Node,Node->getOperand(0)}));
+      return;
+    }
+    case Intrinsic::set_load_nfu: {
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      ConstantSDNode *C3 = dyn_cast<ConstantSDNode>(Node->getOperand(4));
+      ConstantSDNode *C4 = dyn_cast<ConstantSDNode>(Node->getOperand(5));
+      assert(C1 && C2 && C3 && C4 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "C1 Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "C2 Operand exceeds 5 bits");
+      assert(C3->getSExtValue() <= 0x1F && "C3 Operand exceeds 5 bits");
+      assert(C4->getSExtValue() <= 0x1F && "C4 Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+      int64_t Imm3 = C3->getSExtValue() & 0x1F;
+      int64_t Imm4 = C4->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      SDValue Imm3Node = CurDAG->getTargetConstant(Imm3, DL, MVT::i32);
+      SDValue Imm4Node = CurDAG->getTargetConstant(Imm4, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::SET_LOAD_NFU,DL,MVT::Other,{Imm1Node,
+            Imm2Node,Imm3Node,Imm4Node,Node->getOperand(0)}));
+      return;
+    }
     case Intrinsic::riscv_vsseg2:
     case Intrinsic::riscv_vsseg3:
     case Intrinsic::riscv_vsseg4:
diff -ruN llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
--- llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp	2023-05-24 11:35:47.696303128 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp	2023-05-20 23:42:10.528257783 -0400
@@ -167,6 +167,10 @@
     setLoadExtAction(N, XLenVT, MVT::i1, Promote);
 
   // TODO: add all necessary setOperationAction calls.
+  setOperationAction(ISD::EXEC_NFU,MVT::i32,Custom);
+  setOperationAction(ISD::POP_NFU,MVT::Other,Custom);
+  setOperationAction(ISD::SET_LOAD_NFU,MVT::i32,Custom);
+
   setOperationAction(ISD::DYNAMIC_STACKALLOC, XLenVT, Expand);
 
   setOperationAction(ISD::BR_JT, MVT::Other, Expand);
@@ -3560,6 +3564,25 @@
   switch (IntNo) {
   default:
     break; // Don't custom lower most intrinsics.
+  case Intrinsic::exec_nfu: {
+    /*SDValue Src1 = Op.getOperand(1);
+    SDValue Src2 = Op.getOperand(2);
+    SDLoc DL(Op);
+    SDValue Imm1 = DAG.getTargetConstant(cast<ConstantSDNode>(Src1)->getSExtValue(), DL, MVT::i32);
+    SDValue Imm2 = DAG.getTargetConstant(cast<ConstantSDNode>(Src2)->getSExtValue(), DL, MVT::i32);
+    return DAG.getNode(RISCV::EXEC_NFU,DL,XLenVT,Imm1,Imm2);*/
+    ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Op.getOperand(1));
+    ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Op.getOperand(2));
+    assert(C1 && C2 && "Expected constant operands");
+    assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+    assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+    int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+    int64_t Imm2 = C2->getSExtValue() & 0x1F;
+    SDValue Imm1Node = DAG.getTargetConstant(Imm1, DL, MVT::i32);
+    SDValue Imm2Node = DAG.getTargetConstant(Imm2, DL, MVT::i32);
+    return DAG.getNode(ISD::EXEC_NFU,DL,MVT::Other,Imm1Node,Imm2Node);
+  }
   case Intrinsic::thread_pointer: {
     EVT PtrVT = getPointerTy(DAG.getDataLayout());
     return DAG.getRegister(RISCV::X4, PtrVT);
@@ -3710,6 +3733,15 @@
 
 SDValue RISCVTargetLowering::LowerINTRINSIC_W_CHAIN(SDValue Op,
                                                     SelectionDAG &DAG) const {
+  unsigned IntNo = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
+  if(IntNo == Intrinsic::pop_nfu){
+    EVT RetTy = Op.getValueType();
+    SDValue Chain = Op.getOperand(0);
+    SDValue Op1 = Op.getOperand(2);
+    SDValue Op2 = Op.getOperand(3);
+    SDLoc DL(Op);
+    return DAG.getNode(ISD::POP_NFU, DL, RetTy, Chain, Op1, Op2);
+  }
   return lowerVectorIntrinsicSplats(Op, DAG, Subtarget);
 }
 
diff -ruN llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.td
--- llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.td	2023-05-24 11:35:47.712303300 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.td	2022-02-01 09:13:46.435669149 -0500
@@ -2173,7 +2173,7 @@
   def EX   : SideEffectBinaryRX<"ex", 0x44, ADDR64>;
   def EXRL : SideEffectBinaryRILPC<"exrl", 0xC60, ADDR64>;
   let hasNoSchedulingInfo = 1 in
-    def EXRL_Pseudo : Pseudo<(outs), (ins i64imm:$TargetOpc, ADDR64:$lenMinus1,
+    def EXRL_Pseudo : Alias<6, (outs), (ins i64imm:$TargetOpc, ADDR64:$lenMinus1,
                                           bdaddr12only:$bdl1, bdaddr12only:$bd2),
                                           []>;
 }
diff -ruN llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp
--- llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp	2023-05-24 11:35:47.740303602 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp	2022-02-01 09:13:46.435669149 -0500
@@ -657,35 +657,24 @@
                   EntryBlk->end());
   TailBlk->transferSuccessorsAndUpdatePHIs(EntryBlk);
 
-  int64_t FrameIndex = VAStartPseudoInstr->getOperand(1).getImm();
-  Register BaseReg;
-  uint64_t FrameOffset =
-      X86FL->getFrameIndexReference(*Func, FrameIndex, BaseReg).getFixed();
-  uint64_t VarArgsRegsOffset = VAStartPseudoInstr->getOperand(2).getImm();
+  uint64_t FrameOffset = VAStartPseudoInstr->getOperand(4).getImm();
+  uint64_t VarArgsRegsOffset = VAStartPseudoInstr->getOperand(6).getImm();
 
   // TODO: add support for YMM and ZMM here.
   unsigned MOVOpc = STI->hasAVX() ? X86::VMOVAPSmr : X86::MOVAPSmr;
 
   // In the XMM save block, save all the XMM argument registers.
-  for (int64_t OpndIdx = 3, RegIdx = 0;
+  for (int64_t OpndIdx = 7, RegIdx = 0;
        OpndIdx < VAStartPseudoInstr->getNumOperands() - 1;
        OpndIdx++, RegIdx++) {
-
-    int64_t Offset = FrameOffset + VarArgsRegsOffset + RegIdx * 16;
-
-    MachineMemOperand *MMO = Func->getMachineMemOperand(
-        MachinePointerInfo::getFixedStack(*Func, FrameIndex, Offset),
-        MachineMemOperand::MOStore,
-        /*Size=*/16, Align(16));
-
-    BuildMI(GuardedRegsBlk, DL, TII->get(MOVOpc))
-        .addReg(BaseReg)
-        .addImm(/*Scale=*/1)
-        .addReg(/*IndexReg=*/0)
-        .addImm(/*Disp=*/Offset)
-        .addReg(/*Segment=*/0)
-        .addReg(VAStartPseudoInstr->getOperand(OpndIdx).getReg())
-        .addMemOperand(MMO);
+    auto NewMI = BuildMI(GuardedRegsBlk, DL, TII->get(MOVOpc));
+    for (int i = 0; i < X86::AddrNumOperands; ++i) {
+      if (i == X86::AddrDisp)
+        NewMI.addImm(FrameOffset + VarArgsRegsOffset + RegIdx * 16);
+      else
+        NewMI.add(VAStartPseudoInstr->getOperand(i + 1));
+    }
+    NewMI.addReg(VAStartPseudoInstr->getOperand(OpndIdx).getReg());
     assert(Register::isPhysicalRegister(
         VAStartPseudoInstr->getOperand(OpndIdx).getReg()));
   }
diff -ruN llvm-project/llvm/lib/Target/X86/X86InstrCompiler.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86InstrCompiler.td
--- llvm-project/llvm/lib/Target/X86/X86InstrCompiler.td	2023-05-24 11:35:47.760303819 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86InstrCompiler.td	2022-02-01 09:13:46.443669231 -0500
@@ -69,16 +69,12 @@
 let SchedRW = [WriteSystem] in {
 
 // x86-64 va_start lowering magic.
-let hasSideEffects = 1, Defs = [EFLAGS] in {
+let hasSideEffects = 1, mayStore = 1, Defs = [EFLAGS] in {
 def VASTART_SAVE_XMM_REGS : I<0, Pseudo,
                               (outs),
-                              (ins GR8:$al,
-                                   i32imm:$regsavefi, i32imm:$offset,
-                                   variable_ops),
-                              "#VASTART_SAVE_XMM_REGS $al, $regsavefi, $offset",
-                              [(X86vastart_save_xmm_regs GR8:$al,
-                                                         timm:$regsavefi,
-                                                         timm:$offset),
+                              (ins GR8:$al, i8mem:$regsavefi, variable_ops),
+                              "#VASTART_SAVE_XMM_REGS $al, $regsavefi",
+                              [(X86vastart_save_xmm_regs GR8:$al, addr:$regsavefi),
                                (implicit EFLAGS)]>;
 }
 
diff -ruN llvm-project/llvm/lib/Target/X86/X86InstrInfo.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86InstrInfo.td
--- llvm-project/llvm/lib/Target/X86/X86InstrInfo.td	2023-05-24 11:35:47.768303904 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86InstrInfo.td	2022-02-01 09:13:46.443669231 -0500
@@ -91,8 +91,7 @@
 def SDT_X86NtBrind : SDTypeProfile<0, -1, [SDTCisVT<0, iPTR>]>;
 
 def SDT_X86VASTART_SAVE_XMM_REGS : SDTypeProfile<0, -1, [SDTCisVT<0, i8>,
-                                                         SDTCisVT<1, iPTR>,
-                                                         SDTCisVT<2, iPTR>]>;
+                                                         SDTCisPtrTy<1>]>;
 
 def SDT_X86VAARG : SDTypeProfile<1, -1, [SDTCisPtrTy<0>,
                                          SDTCisPtrTy<1>,
@@ -184,7 +183,7 @@
 def X86vastart_save_xmm_regs :
                  SDNode<"X86ISD::VASTART_SAVE_XMM_REGS",
                         SDT_X86VASTART_SAVE_XMM_REGS,
-                        [SDNPHasChain, SDNPVariadic]>;
+                        [SDNPHasChain, SDNPMayStore, SDNPMemOperand, SDNPVariadic]>;
 def X86vaarg64 :
                  SDNode<"X86ISD::VAARG_64", SDT_X86VAARG,
                         [SDNPHasChain, SDNPMayLoad, SDNPMayStore,
diff -ruN llvm-project/llvm/lib/Target/X86/X86InstrSystem.td /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86InstrSystem.td
--- llvm-project/llvm/lib/Target/X86/X86InstrSystem.td	2023-05-24 11:35:47.772303948 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86InstrSystem.td	2022-02-01 09:13:46.443669231 -0500
@@ -583,7 +583,7 @@
 //===----------------------------------------------------------------------===//
 // VIA PadLock crypto instructions
 let Defs = [RAX, RDI], Uses = [RDX, RDI], SchedRW = [WriteSystem] in
-  def XSTORE : I<0xa7, MRM_C0, (outs), (ins), "xstore", []>, TB, REP;
+  def XSTORE : I<0xa7, MRM_C0, (outs), (ins), "xstore", []>, TB;
 
 def : InstAlias<"xstorerng", (XSTORE)>;
 
diff -ruN llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp
--- llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp	2023-05-24 11:35:47.752303731 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp	2022-02-01 09:13:46.443669231 -0500
@@ -3533,13 +3533,19 @@
       SmallVector<SDValue, 12> SaveXMMOps;
       SaveXMMOps.push_back(Chain);
       SaveXMMOps.push_back(ALVal);
-      SaveXMMOps.push_back(
-          DAG.getTargetConstant(FuncInfo->getRegSaveFrameIndex(), DL, MVT::i32));
+      SaveXMMOps.push_back(RSFIN);
       SaveXMMOps.push_back(
           DAG.getTargetConstant(FuncInfo->getVarArgsFPOffset(), DL, MVT::i32));
       llvm::append_range(SaveXMMOps, LiveXMMRegs);
-      MemOps.push_back(DAG.getNode(X86ISD::VASTART_SAVE_XMM_REGS, DL,
-                                   MVT::Other, SaveXMMOps));
+      MachineMemOperand *StoreMMO =
+          DAG.getMachineFunction().getMachineMemOperand(
+              MachinePointerInfo::getFixedStack(
+                  DAG.getMachineFunction(), FuncInfo->getRegSaveFrameIndex(),
+                  Offset),
+              MachineMemOperand::MOStore, 128, Align(16));
+      MemOps.push_back(DAG.getMemIntrinsicNode(X86ISD::VASTART_SAVE_XMM_REGS,
+                                               DL, DAG.getVTList(MVT::Other),
+                                               SaveXMMOps, MVT::i8, StoreMMO));
     }
 
     if (!MemOps.empty())
@@ -44070,32 +44076,9 @@
          "Unexpected horizontal add/sub opcode");
 
   if (!shouldUseHorizontalOp(true, DAG, Subtarget)) {
-    // For slow-hop targets, if we have a hop with a single op, see if we already
-    // have another user that we can reuse and shuffle the result.
     MVT VT = N->getSimpleValueType(0);
     SDValue LHS = N->getOperand(0);
     SDValue RHS = N->getOperand(1);
-    if (VT.is128BitVector() && LHS == RHS) {
-      for (SDNode *User : LHS->uses()) {
-        if (User != N && User->getOpcode() == N->getOpcode()) {
-          MVT ShufVT = VT.isFloatingPoint() ? MVT::v4f32 : MVT::v4i32;
-          if (User->getOperand(0) == LHS && !User->getOperand(1).isUndef()) {
-            return DAG.getBitcast(
-                VT,
-                DAG.getVectorShuffle(ShufVT, SDLoc(N),
-                                     DAG.getBitcast(ShufVT, SDValue(User, 0)),
-                                     DAG.getUNDEF(ShufVT), {0, 1, 0, 1}));
-          }
-          if (User->getOperand(1) == LHS && !User->getOperand(0).isUndef()) {
-            return DAG.getBitcast(
-                VT,
-                DAG.getVectorShuffle(ShufVT, SDLoc(N),
-                                     DAG.getBitcast(ShufVT, SDValue(User, 0)),
-                                     DAG.getUNDEF(ShufVT), {2, 3, 2, 3}));
-          }
-        }
-      }
-    }
 
     // HOP(HOP'(X,X),HOP'(Y,Y)) -> HOP(PERMUTE(HOP'(X,Y)),PERMUTE(HOP'(X,Y)).
     if (LHS != RHS && LHS.getOpcode() == N->getOpcode() &&
diff -ruN llvm-project/llvm/lib/Target/X86/X86ISelLowering.h /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h
--- llvm-project/llvm/lib/Target/X86/X86ISelLowering.h	2023-05-24 11:35:47.752303731 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h	2022-02-01 09:13:46.443669231 -0500
@@ -627,10 +627,6 @@
     // packed single precision.
     DPBF16PS,
 
-    // Save xmm argument registers to the stack, according to %al. An operator
-    // is needed so that this can be expanded with control flow.
-    VASTART_SAVE_XMM_REGS,
-
     // Windows's _chkstk call to do stack probing.
     WIN_ALLOCA,
 
@@ -848,6 +844,10 @@
     AESENCWIDE256KL,
     AESDECWIDE256KL,
 
+    // Save xmm argument registers to the stack, according to %al. An operator
+    // is needed so that this can be expanded with control flow.
+    VASTART_SAVE_XMM_REGS,
+
     // WARNING: Do not add anything in the end unless you want the node to
     // have memop! In fact, starting from FIRST_TARGET_MEMORY_OPCODE all
     // opcodes will be thought as target memory ops!
diff -ruN llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp
--- llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp	2023-05-24 11:35:47.792304163 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp	2022-02-01 09:13:46.443669231 -0500
@@ -29,6 +29,7 @@
 #include "llvm/Analysis/CFG.h"
 #include "llvm/Analysis/CallGraph.h"
 #include "llvm/Analysis/CallGraphSCCPass.h"
+#include "llvm/Analysis/ConstantFolding.h"
 #include "llvm/Analysis/LazyCallGraph.h"
 #include "llvm/IR/Argument.h"
 #include "llvm/IR/Attributes.h"
@@ -1174,6 +1175,15 @@
 static bool simplifyTerminatorLeadingToRet(Instruction *InitialInst) {
   DenseMap<Value *, Value *> ResolvedValues;
   BasicBlock *UnconditionalSucc = nullptr;
+  assert(InitialInst->getModule());
+  const DataLayout &DL = InitialInst->getModule()->getDataLayout();
+
+  auto TryResolveConstant = [&ResolvedValues](Value *V) {
+    auto It = ResolvedValues.find(V);
+    if (It != ResolvedValues.end())
+      V = It->second;
+    return dyn_cast<ConstantInt>(V);
+  };
 
   Instruction *I = InitialInst;
   while (I->isTerminator() ||
@@ -1190,47 +1200,65 @@
     }
     if (auto *BR = dyn_cast<BranchInst>(I)) {
       if (BR->isUnconditional()) {
-        BasicBlock *BB = BR->getSuccessor(0);
+        BasicBlock *Succ = BR->getSuccessor(0);
         if (I == InitialInst)
-          UnconditionalSucc = BB;
-        scanPHIsAndUpdateValueMap(I, BB, ResolvedValues);
-        I = BB->getFirstNonPHIOrDbgOrLifetime();
+          UnconditionalSucc = Succ;
+        scanPHIsAndUpdateValueMap(I, Succ, ResolvedValues);
+        I = Succ->getFirstNonPHIOrDbgOrLifetime();
+        continue;
+      }
+
+      BasicBlock *BB = BR->getParent();
+      // Handle the case the condition of the conditional branch is constant.
+      // e.g.,
+      //
+      //     br i1 false, label %cleanup, label %CoroEnd
+      //
+      // It is possible during the transformation. We could continue the
+      // simplifying in this case.
+      if (ConstantFoldTerminator(BB, /*DeleteDeadConditions=*/true)) {
+        // Handle this branch in next iteration.
+        I = BB->getTerminator();
         continue;
       }
     } else if (auto *CondCmp = dyn_cast<CmpInst>(I)) {
+      // If the case number of suspended switch instruction is reduced to
+      // 1, then it is simplified to CmpInst in llvm::ConstantFoldTerminator.
       auto *BR = dyn_cast<BranchInst>(I->getNextNode());
-      if (BR && BR->isConditional() && CondCmp == BR->getCondition()) {
-        // If the case number of suspended switch instruction is reduced to
-        // 1, then it is simplified to CmpInst in llvm::ConstantFoldTerminator.
-        // And the comparsion looks like : %cond = icmp eq i8 %V, constant.
-        ConstantInt *CondConst = dyn_cast<ConstantInt>(CondCmp->getOperand(1));
-        if (CondConst && CondCmp->getPredicate() == CmpInst::ICMP_EQ) {
-          Value *V = CondCmp->getOperand(0);
-          auto it = ResolvedValues.find(V);
-          if (it != ResolvedValues.end())
-            V = it->second;
-
-          if (ConstantInt *Cond0 = dyn_cast<ConstantInt>(V)) {
-            BasicBlock *BB = Cond0->equalsInt(CondConst->getZExtValue())
-                                 ? BR->getSuccessor(0)
-                                 : BR->getSuccessor(1);
-            scanPHIsAndUpdateValueMap(I, BB, ResolvedValues);
-            I = BB->getFirstNonPHIOrDbgOrLifetime();
-            continue;
-          }
-        }
-      }
+      if (!BR || !BR->isConditional() || CondCmp != BR->getCondition())
+        return false;
+
+      // And the comparsion looks like : %cond = icmp eq i8 %V, constant.
+      // So we try to resolve constant for the first operand only since the
+      // second operand should be literal constant by design.
+      ConstantInt *Cond0 = TryResolveConstant(CondCmp->getOperand(0));
+      auto *Cond1 = dyn_cast<ConstantInt>(CondCmp->getOperand(1));
+      if (!Cond0 || !Cond1)
+        return false;
+
+      // Both operands of the CmpInst are Constant. So that we could evaluate
+      // it immediately to get the destination.
+      auto *ConstResult =
+          dyn_cast_or_null<ConstantInt>(ConstantFoldCompareInstOperands(
+              CondCmp->getPredicate(), Cond0, Cond1, DL));
+      if (!ConstResult)
+        return false;
+
+      CondCmp->replaceAllUsesWith(ConstResult);
+      CondCmp->eraseFromParent();
+
+      // Handle this branch in next iteration.
+      I = BR;
+      continue;
     } else if (auto *SI = dyn_cast<SwitchInst>(I)) {
-      Value *V = SI->getCondition();
-      auto it = ResolvedValues.find(V);
-      if (it != ResolvedValues.end())
-        V = it->second;
-      if (ConstantInt *Cond = dyn_cast<ConstantInt>(V)) {
-        BasicBlock *BB = SI->findCaseValue(Cond)->getCaseSuccessor();
-        scanPHIsAndUpdateValueMap(I, BB, ResolvedValues);
-        I = BB->getFirstNonPHIOrDbgOrLifetime();
-        continue;
-      }
+      ConstantInt *Cond = TryResolveConstant(SI->getCondition());
+      if (!Cond)
+        return false;
+
+      BasicBlock *BB = SI->findCaseValue(Cond)->getCaseSuccessor();
+      scanPHIsAndUpdateValueMap(I, BB, ResolvedValues);
+      I = BB->getFirstNonPHIOrDbgOrLifetime();
+      continue;
     }
     return false;
   }
diff -ruN llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
--- llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp	2023-05-24 11:35:47.820304466 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp	2022-02-01 09:13:46.447669272 -0500
@@ -2843,6 +2843,26 @@
   }
   assert(FreeInstrBB->size() == 1 &&
          "Only the branch instruction should remain");
+
+  // Now that we've moved the call to free before the NULL check, we have to
+  // remove any attributes on its parameter that imply it's non-null, because
+  // those attributes might have only been valid because of the NULL check, and
+  // we can get miscompiles if we keep them. This is conservative if non-null is
+  // also implied by something other than the NULL check, but it's guaranteed to
+  // be correct, and the conservativeness won't matter in practice, since the
+  // attributes are irrelevant for the call to free itself and the pointer
+  // shouldn't be used after the call.
+  AttributeList Attrs = FI.getAttributes();
+  Attrs = Attrs.removeParamAttribute(FI.getContext(), 0, Attribute::NonNull);
+  Attribute Dereferenceable = Attrs.getParamAttr(0, Attribute::Dereferenceable);
+  if (Dereferenceable.isValid()) {
+    uint64_t Bytes = Dereferenceable.getDereferenceableBytes();
+    Attrs = Attrs.removeParamAttribute(FI.getContext(), 0,
+                                       Attribute::Dereferenceable);
+    Attrs = Attrs.addDereferenceableOrNullParamAttr(FI.getContext(), 0, Bytes);
+  }
+  FI.setAttributes(Attrs);
+
   return &FI;
 }
 
diff -ruN llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp
--- llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp	2023-05-24 11:35:47.836304639 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp	2022-02-01 09:13:46.447669272 -0500
@@ -1303,17 +1303,10 @@
   /// loop. In particular, this guarantees that it only references a single
   /// MemoryLocation during execution of the containing function.
   bool isGuaranteedLoopInvariant(const Value *Ptr) {
-    auto IsGuaranteedLoopInvariantBase = [this](const Value *Ptr) {
+    auto IsGuaranteedLoopInvariantBase = [](const Value *Ptr) {
       Ptr = Ptr->stripPointerCasts();
-      if (auto *I = dyn_cast<Instruction>(Ptr)) {
-        if (isa<AllocaInst>(Ptr))
-          return true;
-
-        if (isAllocLikeFn(I, &TLI))
-          return true;
-
-        return false;
-      }
+      if (auto *I = dyn_cast<Instruction>(Ptr))
+        return I->getParent()->isEntryBlock();
       return true;
     };
 
diff -ruN llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp
--- llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp	2023-05-24 11:35:47.848304768 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp	2022-02-01 09:13:46.447669272 -0500
@@ -154,6 +154,10 @@
     return {};
   }
   Value *const Addr = LoadI->getOperand(0);
+  if (Addr->getType()->getPointerAddressSpace() != 0) {
+    LLVM_DEBUG(dbgs() << "from non-zero AddressSpace\n");
+    return {};
+  }
   auto *const GEP = dyn_cast<GetElementPtrInst>(Addr);
   if (!GEP)
     return {};
diff -ruN llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
--- llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp	2023-05-24 11:35:47.872305026 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp	2022-02-01 09:13:46.447669272 -0500
@@ -144,6 +144,10 @@
   Value *Offset =
       Builder.CreateShl(Index, ConstantInt::get(IntTy, 2), "reltable.shift");
 
+  // Insert the call to load.relative instrinsic before LOAD.
+  // GEP might not be immediately followed by a LOAD, like it can be hoisted
+  // outside the loop or another instruction might be inserted them in between.
+  Builder.SetInsertPoint(Load);
   Function *LoadRelIntrinsic = llvm::Intrinsic::getDeclaration(
       &M, Intrinsic::load_relative, {Index->getType()});
   Value *Base = Builder.CreateBitCast(RelLookupTable, Builder.getInt8PtrTy());
diff -ruN llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
--- llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp	2023-05-24 11:35:47.884305157 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp	2022-02-01 09:13:46.447669272 -0500
@@ -5430,8 +5430,11 @@
         // The pointer operand uses an in-tree scalar so we add the new BitCast
         // to ExternalUses list to make sure that an extract will be generated
         // in the future.
-        if (getTreeEntry(PO))
-          ExternalUses.emplace_back(PO, cast<User>(VecPtr), 0);
+        if (TreeEntry *Entry = getTreeEntry(PO)) {
+          // Find which lane we need to extract.
+          unsigned FoundLane = Entry->findLaneForValue(PO);
+          ExternalUses.emplace_back(PO, cast<User>(VecPtr), FoundLane);
+        }
 
         NewLI = Builder.CreateAlignedLoad(VecTy, VecPtr, LI->getAlign());
       } else {
@@ -5474,8 +5477,12 @@
       // The pointer operand uses an in-tree scalar, so add the new BitCast to
       // ExternalUses to make sure that an extract will be generated in the
       // future.
-      if (getTreeEntry(ScalarPtr))
-        ExternalUses.push_back(ExternalUser(ScalarPtr, cast<User>(VecPtr), 0));
+      if (TreeEntry *Entry = getTreeEntry(ScalarPtr)) {
+        // Find which lane we need to extract.
+        unsigned FoundLane = Entry->findLaneForValue(ScalarPtr);
+        ExternalUses.push_back(
+            ExternalUser(ScalarPtr, cast<User>(VecPtr), FoundLane));
+      }
 
       Value *V = propagateMetadata(ST, E->Scalars);
 
@@ -5577,8 +5584,14 @@
       // The scalar argument uses an in-tree scalar so we add the new vectorized
       // call to ExternalUses list to make sure that an extract will be
       // generated in the future.
-      if (ScalarArg && getTreeEntry(ScalarArg))
-        ExternalUses.push_back(ExternalUser(ScalarArg, cast<User>(V), 0));
+      if (ScalarArg) {
+        if (TreeEntry *Entry = getTreeEntry(ScalarArg)) {
+          // Find which lane we need to extract.
+          unsigned FoundLane = Entry->findLaneForValue(ScalarArg);
+          ExternalUses.push_back(
+              ExternalUser(ScalarArg, cast<User>(V), FoundLane));
+        }
+      }
 
       propagateIRFlags(V, E->Scalars, VL0);
       ShuffleBuilder.addMask(E->ReuseShuffleIndices);
diff -ruN llvm-project/llvm/test/Analysis/BasicAA/pr52735.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Analysis/BasicAA/pr52735.ll
--- llvm-project/llvm/test/Analysis/BasicAA/pr52735.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Analysis/BasicAA/pr52735.ll	2022-02-01 09:13:46.447669272 -0500
@@ -0,0 +1,29 @@
+; RUN: opt %s -basic-aa -aa-eval -print-all-alias-modref-info -disable-output 2>&1 | FileCheck %s
+;
+; Generated from:
+;
+; int foo() {
+;   int v;
+;   asm goto("movl $1, %0" : "=m"(v)::: out);
+; out:
+;   return v;
+; }
+
+target triple = "x86_64-unknown-linux-gnu"
+
+; CHECK: MayAlias: i32* %v, void (i32*, i8*)* asm "movl $$1, $0", "=*m,X,~{dirflag},~{fpsr},~{flags}"
+
+define dso_local i32 @foo() {
+entry:
+  %v = alloca i32, align 4
+  %0 = bitcast i32* %v to i8*
+  callbr void asm "movl $$1, $0", "=*m,X,~{dirflag},~{fpsr},~{flags}"(i32* nonnull %v, i8* blockaddress(@foo, %out))
+          to label %asm.fallthrough [label %out]
+
+asm.fallthrough:
+  br label %out
+
+out:
+  %1 = load i32, i32* %v, align 4
+  ret i32 %1
+}
diff -ruN llvm-project/llvm/test/Analysis/LazyCallGraph/blockaddress.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Analysis/LazyCallGraph/blockaddress.ll
--- llvm-project/llvm/test/Analysis/LazyCallGraph/blockaddress.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Analysis/LazyCallGraph/blockaddress.ll	2022-02-01 09:13:46.447669272 -0500
@@ -0,0 +1,28 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt -passes="cgscc(function(sccp,simplifycfg))" < %s -S | FileCheck %s
+
+define i32 @baz(i32 %y, i1 %b) {
+; CHECK-LABEL: @baz(
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    br i1 [[B:%.*]], label [[LAB:%.*]], label [[FOR_COND:%.*]]
+; CHECK:       for.cond:
+; CHECK-NEXT:    [[P_0:%.*]] = phi i8* [ null, [[FOR_COND]] ], [ blockaddress(@baz, [[LAB]]), [[ENTRY:%.*]] ]
+; CHECK-NEXT:    [[INCDEC_PTR:%.*]] = getelementptr inbounds i8, i8* [[P_0]], i64 1
+; CHECK-NEXT:    br label [[FOR_COND]]
+; CHECK:       lab:
+; CHECK-NEXT:    ret i32 0
+;
+entry:
+  br i1 %b, label %lab, label %for.cond.preheader
+
+for.cond.preheader:
+  br label %for.cond
+
+for.cond:
+  %p.0 = phi i8* [ null, %for.cond ], [ blockaddress(@baz, %lab), %for.cond.preheader ]
+  %incdec.ptr = getelementptr inbounds i8, i8* %p.0, i64 1
+  br label %for.cond
+
+lab:
+  ret i32 0
+}
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/elim-dead-mi.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/elim-dead-mi.mir
--- llvm-project/llvm/test/CodeGen/AArch64/elim-dead-mi.mir	2023-05-24 11:35:48.040306840 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/elim-dead-mi.mir	2022-02-01 09:13:46.447669272 -0500
@@ -13,18 +13,18 @@
 name:            main
 tracksRegLiveness: true
 registers:
-  - { id: 0, class: gpr64, preferred-register: '' }
+  - { id: 0, class: gpr64common, preferred-register: '' }
   - { id: 1, class: gpr64common, preferred-register: '' }
   - { id: 2, class: gpr64, preferred-register: '' }
   - { id: 3, class: gpr64common, preferred-register: '' }
   - { id: 4, class: gpr32, preferred-register: '' }
   - { id: 5, class: gpr32all, preferred-register: '' }
-  - { id: 6, class: gpr64, preferred-register: '' }
+  - { id: 6, class: gpr64common, preferred-register: '' }
 body:             |
   bb.0:
     successors: %bb.4(0x30000000), %bb.5(0x50000000)
 
-    %0:gpr64 = MOVaddr target-flags(aarch64-page) @c, target-flags(aarch64-pageoff, aarch64-nc) @c
+    %0:gpr64common = MOVaddr target-flags(aarch64-page) @c, target-flags(aarch64-pageoff, aarch64-nc) @c
     CBZX killed %0, %bb.4
     B %bb.5
 
@@ -55,7 +55,7 @@
   bb.5:
     successors: %bb.1(0x80000000)
     ; CHECK: bb.5
-    ; CHECK-NOT: %6:gpr64 = MOVaddr target-flags(aarch64-page) @c, target-flags(aarch64-pageoff, aarch64-nc) @c
-    %6:gpr64 = MOVaddr target-flags(aarch64-page) @c, target-flags(aarch64-pageoff, aarch64-nc) @c
+    ; CHECK-NOT: %6:gpr64common = MOVaddr target-flags(aarch64-page) @c, target-flags(aarch64-pageoff, aarch64-nc) @c
+    %6:gpr64common = MOVaddr target-flags(aarch64-page) @c, target-flags(aarch64-pageoff, aarch64-nc) @c
     B %bb.1
 ...
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/rbs-matrixindex-regclass-crash.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/rbs-matrixindex-regclass-crash.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/rbs-matrixindex-regclass-crash.mir	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/rbs-matrixindex-regclass-crash.mir	2022-02-01 09:13:46.447669272 -0500
@@ -0,0 +1,56 @@
+# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
+# RUN: llc -mtriple=aarch64 -run-pass=regbankselect -verify-machineinstrs %s -o - | FileCheck %s
+
+# Check we don't crash because of an unhandled new regclass GPR64_with_sub_32_in_MatrixIndexGPR32_12_15RegClassID.
+---
+name:            foo
+alignment:       4
+legalized:       true
+tracksRegLiveness: true
+body:             |
+  bb.1:
+    ; CHECK-LABEL: name: foo
+    ; CHECK: [[DEF:%[0-9]+]]:gpr(s64) = G_IMPLICIT_DEF
+    ; CHECK-NEXT: $x0 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x1 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x2 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x3 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x4 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x5 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x6 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x7 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x8 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x9 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x10 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x11 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x12 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x13 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x14 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x15 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x16 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: $x17 = COPY [[DEF]](s64)
+    ; CHECK-NEXT: INLINEASM &"svc 0", 1 /* sideeffect attdialect */, 10 /* regdef */, implicit-def $x0, 10 /* regdef */, implicit-def $x1, 10 /* regdef */, implicit-def $x2, 10 /* regdef */, implicit-def $x3, 10 /* regdef */, implicit-def $x4, 10 /* regdef */, implicit-def $x5, 10 /* regdef */, implicit-def $x6, 10 /* regdef */, implicit-def $x7, 10 /* regdef */, implicit-def $x8, 10 /* regdef */, implicit-def $x9, 10 /* regdef */, implicit-def $x10, 10 /* regdef */, implicit-def $x11, 10 /* regdef */, implicit-def $x12, 10 /* regdef */, implicit-def $x13, 10 /* regdef */, implicit-def $x14, 10 /* regdef */, implicit-def $x15, 10 /* regdef */, implicit-def $x16, 10 /* regdef */, implicit-def $x17, 9 /* reguse */, $x0, 9 /* reguse */, $x1, 9 /* reguse */, $x2, 9 /* reguse */, $x3, 9 /* reguse */, $x4, 9 /* reguse */, $x5, 9 /* reguse */, $x6, 9 /* reguse */, $x7, 9 /* reguse */, $x8, 9 /* reguse */, $x9, 9 /* reguse */, $x10, 9 /* reguse */, $x11, 9 /* reguse */, $x12, 9 /* reguse */, $x13, 9 /* reguse */, $x14, 9 /* reguse */, $x15, 9 /* reguse */, $x16, 9 /* reguse */, $x17
+    ; CHECK-NEXT: RET_ReallyLR
+    %0:_(s64) = G_IMPLICIT_DEF
+    $x0 = COPY %0(s64)
+    $x1 = COPY %0(s64)
+    $x2 = COPY %0(s64)
+    $x3 = COPY %0(s64)
+    $x4 = COPY %0(s64)
+    $x5 = COPY %0(s64)
+    $x6 = COPY %0(s64)
+    $x7 = COPY %0(s64)
+    $x8 = COPY %0(s64)
+    $x9 = COPY %0(s64)
+    $x10 = COPY %0(s64)
+    $x11 = COPY %0(s64)
+    $x12 = COPY %0(s64)
+    $x13 = COPY %0(s64)
+    $x14 = COPY %0(s64)
+    $x15 = COPY %0(s64)
+    $x16 = COPY %0(s64)
+    $x17 = COPY %0(s64)
+    INLINEASM &"svc 0", 1 /* sideeffect attdialect */, 10 /* regdef */, implicit-def $x0, 10 /* regdef */, implicit-def $x1, 10 /* regdef */, implicit-def $x2, 10 /* regdef */, implicit-def $x3, 10 /* regdef */, implicit-def $x4, 10 /* regdef */, implicit-def $x5, 10 /* regdef */, implicit-def $x6, 10 /* regdef */, implicit-def $x7, 10 /* regdef */, implicit-def $x8, 10 /* regdef */, implicit-def $x9, 10 /* regdef */, implicit-def $x10, 10 /* regdef */, implicit-def $x11, 10 /* regdef */, implicit-def $x12, 10 /* regdef */, implicit-def $x13, 10 /* regdef */, implicit-def $x14, 10 /* regdef */, implicit-def $x15, 10 /* regdef */, implicit-def $x16, 10 /* regdef */, implicit-def $x17, 9 /* reguse */, $x0, 9 /* reguse */, $x1, 9 /* reguse */, $x2, 9 /* reguse */, $x3, 9 /* reguse */, $x4, 9 /* reguse */, $x5, 9 /* reguse */, $x6, 9 /* reguse */, $x7, 9 /* reguse */, $x8, 9 /* reguse */, $x9, 9 /* reguse */, $x10, 9 /* reguse */, $x11, 9 /* reguse */, $x12, 9 /* reguse */, $x13, 9 /* reguse */, $x14, 9 /* reguse */, $x15, 9 /* reguse */, $x16, 9 /* reguse */, $x17
+    RET_ReallyLR
+
+...
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-add-low.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-add-low.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-add-low.mir	2023-05-24 11:35:48.008306495 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-add-low.mir	2022-02-01 09:13:46.447669272 -0500
@@ -20,7 +20,7 @@
     liveins: $x0
     ; CHECK-LABEL: name: select_add_low_without_offset
     ; CHECK: liveins: $x0
-    ; CHECK: %add_low:gpr64 = MOVaddr target-flags(aarch64-page) @x, target-flags(aarch64-pageoff, aarch64-nc) @x
+    ; CHECK: %add_low:gpr64common = MOVaddr target-flags(aarch64-page) @x, target-flags(aarch64-pageoff, aarch64-nc) @x
     ; CHECK: $x0 = COPY %add_low
     ; CHECK: RET_ReallyLR implicit $x0
     %copy:gpr(p0) = COPY $x0
@@ -40,7 +40,7 @@
     liveins: $x0
     ; CHECK-LABEL: name: select_add_low_with_offset
     ; CHECK: liveins: $x0
-    ; CHECK: %add_low:gpr64 = MOVaddr target-flags(aarch64-page) @x + 1, target-flags(aarch64-pageoff, aarch64-nc) @x + 1
+    ; CHECK: %add_low:gpr64common = MOVaddr target-flags(aarch64-page) @x + 1, target-flags(aarch64-pageoff, aarch64-nc) @x + 1
     ; CHECK: $x0 = COPY %add_low
     ; CHECK: RET_ReallyLR implicit $x0
     %copy:gpr(p0) = COPY $x0
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-blockaddress.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-blockaddress.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-blockaddress.mir	2023-05-24 11:35:48.012306539 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-blockaddress.mir	2022-02-01 09:13:46.447669272 -0500
@@ -30,9 +30,10 @@
 body:             |
   ; CHECK-LABEL: name: test_blockaddress
   ; CHECK: bb.0 (%ir-block.0):
-  ; CHECK:   [[MOVaddrBA:%[0-9]+]]:gpr64 = MOVaddrBA target-flags(aarch64-page) blockaddress(@test_blockaddress, %ir-block.block), target-flags(aarch64-pageoff, aarch64-nc) blockaddress(@test_blockaddress, %ir-block.block)
+  ; CHECK:   [[MOVaddrBA:%[0-9]+]]:gpr64common = MOVaddrBA target-flags(aarch64-page) blockaddress(@test_blockaddress, %ir-block.block), target-flags(aarch64-pageoff, aarch64-nc) blockaddress(@test_blockaddress, %ir-block.block)
   ; CHECK:   [[MOVaddr:%[0-9]+]]:gpr64common = MOVaddr target-flags(aarch64-page) @addr, target-flags(aarch64-pageoff, aarch64-nc) @addr
-  ; CHECK:   STRXui [[MOVaddrBA]], [[MOVaddr]], 0 :: (store (p0) into @addr)
+  ; CHECK:   [[COPY:%[0-9]+]]:gpr64 = COPY [[MOVaddrBA]]
+  ; CHECK:   STRXui [[COPY]], [[MOVaddr]], 0 :: (store (p0) into @addr)
   ; CHECK:   BR [[MOVaddrBA]]
   ; CHECK: bb.1.block (address-taken):
   ; CHECK:   RET_ReallyLR
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-gv-with-offset.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-gv-with-offset.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-gv-with-offset.mir	2023-05-24 11:35:48.012306539 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-gv-with-offset.mir	2022-02-01 09:13:46.447669272 -0500
@@ -25,7 +25,7 @@
     ; LARGE: RET_ReallyLR implicit $x0
     ; SMALL-LABEL: name: select_gv_with_offset
     ; SMALL: liveins: $x0
-    ; SMALL: %g:gpr64 = MOVaddr target-flags(aarch64-page) @g + 1, target-flags(aarch64-pageoff, aarch64-nc) @g + 1
+    ; SMALL: %g:gpr64common = MOVaddr target-flags(aarch64-page) @g + 1, target-flags(aarch64-pageoff, aarch64-nc) @g + 1
     ; SMALL: $x0 = COPY %g
     ; SMALL: RET_ReallyLR implicit $x0
     ; TINY-LABEL: name: select_gv_with_offset
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt-constrain.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt-constrain.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt-constrain.mir	2023-05-24 11:35:48.012306539 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt-constrain.mir	2022-02-01 09:13:46.447669272 -0500
@@ -30,7 +30,7 @@
   ; CHECK:   Bcc 8, %bb.3, implicit $nzcv
   ; CHECK: bb.1:
   ; CHECK:   successors: %bb.2(0x40000000), %bb.3(0x40000000)
-  ; CHECK:   [[MOVaddrJT:%[0-9]+]]:gpr64 = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
+  ; CHECK:   [[MOVaddrJT:%[0-9]+]]:gpr64common = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
   ; CHECK:   early-clobber %6:gpr64, early-clobber %7:gpr64sp = JumpTableDest32 [[MOVaddrJT]], [[SUBREG_TO_REG]], %jump-table.0
   ; CHECK:   BR %6
   ; CHECK: bb.2:
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt.mir	2023-05-24 11:35:48.012306539 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-jump-table-brjt.mir	2022-02-01 09:13:46.447669272 -0500
@@ -65,7 +65,7 @@
   ; CHECK: bb.1.entry:
   ; CHECK:   successors: %bb.3(0x2aaaaaab), %bb.4(0x2aaaaaab), %bb.2(0x2aaaaaab)
   ; CHECK:   [[COPY2:%[0-9]+]]:gpr32 = COPY $wzr
-  ; CHECK:   [[MOVaddrJT:%[0-9]+]]:gpr64 = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
+  ; CHECK:   [[MOVaddrJT:%[0-9]+]]:gpr64common = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
   ; CHECK:   early-clobber %18:gpr64, early-clobber %19:gpr64sp = JumpTableDest32 [[MOVaddrJT]], [[SUBREG_TO_REG]], %jump-table.0
   ; CHECK:   BR %18
   ; CHECK: bb.2.sw.bb:
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select.mir	2023-05-24 11:35:48.016306581 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select.mir	2022-02-01 09:13:46.447669272 -0500
@@ -76,8 +76,8 @@
   - { id: 0, class: gpr }
 
 # CHECK:  body:
-# IOS: %0:gpr64 = MOVaddr target-flags(aarch64-page) @var_local, target-flags(aarch64-pageoff, aarch64-nc) @var_local
-# LINUX-PIC: %0:gpr64 = LOADgot target-flags(aarch64-got) @var_local
+# IOS: %0:gpr64common = MOVaddr target-flags(aarch64-page) @var_local, target-flags(aarch64-pageoff, aarch64-nc) @var_local
+# LINUX-PIC: %0:gpr64common = LOADgot target-flags(aarch64-got) @var_local
 body:             |
   bb.0:
     %0(p0) = G_GLOBAL_VALUE @var_local
@@ -93,8 +93,8 @@
   - { id: 0, class: gpr }
 
 # CHECK:  body:
-# IOS: %0:gpr64 = LOADgot target-flags(aarch64-got) @var_got
-# LINUX-PIC: %0:gpr64 = LOADgot target-flags(aarch64-got) @var_got
+# IOS: %0:gpr64common = LOADgot target-flags(aarch64-got) @var_got
+# LINUX-PIC: %0:gpr64common = LOADgot target-flags(aarch64-got) @var_got
 body:             |
   bb.0:
     %0(p0) = G_GLOBAL_VALUE @var_got
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-static.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-static.mir
--- llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-static.mir	2023-05-24 11:35:48.012306539 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/GlobalISel/select-static.mir	2022-02-01 09:13:46.447669272 -0500
@@ -75,7 +75,7 @@
   - { id: 0, class: gpr }
 
 # CHECK:  body:
-# LINUX-DEFAULT: %0:gpr64 = MOVaddr target-flags(aarch64-page) @var_local, target-flags(aarch64-pageoff, aarch64-nc) @var_local
+# LINUX-DEFAULT: %0:gpr64common = MOVaddr target-flags(aarch64-page) @var_local, target-flags(aarch64-pageoff, aarch64-nc) @var_local
 body:             |
   bb.0:
     %0(p0) = G_GLOBAL_VALUE @var_local
@@ -91,7 +91,7 @@
   - { id: 0, class: gpr }
 
 # CHECK:  body:
-# LINUX-DEFAULT: %0:gpr64 = MOVaddr target-flags(aarch64-page) @var_got, target-flags(aarch64-pageoff, aarch64-nc) @var_got
+# LINUX-DEFAULT: %0:gpr64common = MOVaddr target-flags(aarch64-page) @var_got, target-flags(aarch64-pageoff, aarch64-nc) @var_got
 body:             |
   bb.0:
     %0(p0) = G_GLOBAL_VALUE @var_got
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/loop-sink.mir /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/loop-sink.mir
--- llvm-project/llvm/test/CodeGen/AArch64/loop-sink.mir	2023-05-24 11:35:48.052306969 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/loop-sink.mir	2022-02-01 09:13:46.447669272 -0500
@@ -274,7 +274,7 @@
   - { id: 17, class: gpr32, preferred-register: '' }
   - { id: 18, class: gpr32sp, preferred-register: '' }
   - { id: 19, class: gpr32, preferred-register: '' }
-  - { id: 20, class: gpr64, preferred-register: '' }
+  - { id: 20, class: gpr64common, preferred-register: '' }
   - { id: 21, class: gpr64, preferred-register: '' }
   - { id: 22, class: gpr64sp, preferred-register: '' }
   - { id: 23, class: gpr64sp, preferred-register: '' }
@@ -338,7 +338,7 @@
   ; CHECK:   [[COPY6:%[0-9]+]]:gpr64all = COPY [[ADDXri4]]
   ; CHECK:   [[ADDXri5:%[0-9]+]]:gpr64sp = ADDXri [[COPY1]], 1, 0
   ; CHECK:   [[COPY7:%[0-9]+]]:gpr64all = COPY [[ADDXri5]]
-  ; CHECK:   [[MOVaddrJT:%[0-9]+]]:gpr64 = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
+  ; CHECK:   [[MOVaddrJT:%[0-9]+]]:gpr64common = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
   ; CHECK: bb.1..backedge:
   ; CHECK:   successors: %bb.9(0x09249249), %bb.2(0x76db6db7)
   ; CHECK:   [[PHI:%[0-9]+]]:gpr64sp = PHI [[COPY7]], %bb.0, %7, %bb.9
@@ -415,7 +415,7 @@
     %4:gpr64all = COPY %14
     %15:gpr64sp = ADDXri %8, 1, 0
     %5:gpr64all = COPY %15
-    %20:gpr64 = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
+    %20:gpr64common = MOVaddrJT target-flags(aarch64-page) %jump-table.0, target-flags(aarch64-pageoff, aarch64-nc) %jump-table.0
 
   bb.1..backedge:
     successors: %bb.8(0x09249249), %bb.9(0x76db6db7)
diff -ruN llvm-project/llvm/test/CodeGen/AArch64/machine-outliner-patchable.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/machine-outliner-patchable.ll
--- llvm-project/llvm/test/CodeGen/AArch64/machine-outliner-patchable.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/AArch64/machine-outliner-patchable.ll	2022-02-01 09:13:46.447669272 -0500
@@ -0,0 +1,114 @@
+; RUN: llc < %s -verify-machineinstrs -enable-machine-outliner | FileCheck %s
+
+target triple = "aarch64-unknown-linux-gnu"
+
+declare void @foo(i32, i32, i32, i32) minsize
+
+;; TargetOpcode::FENTRY_CALL at the start of the function expands to a __fentry__
+;; call which must be present. Don't outline it.
+define void @fentry0(i1 %a) nounwind "fentry-call"="true" {
+; CHECK-LABEL: fentry0:
+; CHECK-NEXT:  // %bb.0:
+; CHECK-NEXT:    # FEntry call
+; CHECK:       // %bb.1:
+; CHECK-NEXT:    bl OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+define void @fentry1(i1 %a) nounwind "fentry-call"="true" {
+; CHECK-LABEL: fentry1:
+; CHECK-NEXT:  // %bb.0:
+; CHECK-NEXT:    # FEntry call
+; CHECK:       // %bb.1:
+; CHECK-NEXT:    bl OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+;; TargetOpcode::PATCHABLE_FUNCTION_ENTER at the start of the function expands to
+;; NOPs which must be present. Don't outline them.
+define void @patchable0(i1 %a) nounwind "patchable-function-entry"="2" {
+; CHECK-LABEL: patchable0:
+; CHECK-NEXT:  .Lfunc_begin0:
+; CHECK-NEXT:  // %bb.0:
+; CHECK-NEXT:    nop
+; CHECK-NEXT:    nop
+; CHECK:       // %bb.1:
+; CHECK-NEXT:    bl OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+define void @patchable1(i1 %a) nounwind "patchable-function-entry"="2" {
+; CHECK-LABEL: patchable1:
+; CHECK-NEXT:  .Lfunc_begin1:
+; CHECK-NEXT:  // %bb.0:
+; CHECK-NEXT:    nop
+; CHECK-NEXT:    nop
+; CHECK:       // %bb.1:
+; CHECK-NEXT:    bl OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+;; Similar to "patchable-function-entry".
+define void @xray0(i1 %a) nounwind "function-instrument"="xray-always" {
+; CHECK-LABEL: xray0:
+; CHECK-NEXT:  .Lfunc_begin2:
+; CHECK-NEXT:  // %bb.0:
+; CHECK-NEXT:  .p2align 2
+; CHECK-NEXT:  .Lxray_sled_0:
+; CHECK:       // %bb.1:
+; CHECK-NEXT:    bl OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+define void @xray1(i1 %a) nounwind "function-instrument"="xray-always" {
+; CHECK-LABEL: xray1:
+; CHECK-NEXT:  .Lfunc_begin3:
+; CHECK-NEXT:  // %bb.0:
+; CHECK-NEXT:  .p2align 2
+; CHECK-NEXT:  .Lxray_sled_2:
+; CHECK:       // %bb.1:
+; CHECK-NEXT:    bl OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
diff -ruN llvm-project/llvm/test/CodeGen/ARM/fast-call-frame-restore.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/fast-call-frame-restore.ll
--- llvm-project/llvm/test/CodeGen/ARM/fast-call-frame-restore.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/fast-call-frame-restore.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,19 @@
+; RUN: llc -mtriple=armv7-linux-gnueabi %s -o - | FileCheck %s
+
+declare void @bar(i8*, i32, i32, i32, i32)
+
+define void @foo(i32 %amt) optnone noinline {
+  br label %next
+
+next:
+  %mem = alloca i8;, i32 %amt
+  br label %next1
+
+next1:
+  call void @bar(i8* %mem, i32 undef, i32 undef, i32 undef, i32 undef)
+; CHECK: sub sp, sp, #8
+; CHECK: bl bar
+; CHECK: add sp, sp, #8
+
+  ret void
+}
diff -ruN llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-call-lowering.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-call-lowering.ll
--- llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-call-lowering.ll	2023-05-24 11:35:48.316309820 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-call-lowering.ll	2022-02-01 09:13:46.451669313 -0500
@@ -11,7 +11,7 @@
   ; NOV4T:   [[COPY:%[0-9]+]]:tgpr(p0) = COPY $r0
   ; NOV4T:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; NOV4T:   BMOVPCRX_CALL [[COPY]](p0), csr_aapcs, implicit-def $lr, implicit $sp
-  ; NOV4T:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; NOV4T:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; NOV4T:   MOVPCLR 14 /* CC::al */, $noreg
   ; V4T-LABEL: name: test_indirect_call
   ; V4T: bb.1.entry:
@@ -19,7 +19,7 @@
   ; V4T:   [[COPY:%[0-9]+]]:tgpr(p0) = COPY $r0
   ; V4T:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V4T:   BX_CALL [[COPY]](p0), csr_aapcs, implicit-def $lr, implicit $sp
-  ; V4T:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; V4T:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V4T:   BX_RET 14 /* CC::al */, $noreg
   ; V5T-LABEL: name: test_indirect_call
   ; V5T: bb.1.entry:
@@ -27,7 +27,7 @@
   ; V5T:   [[COPY:%[0-9]+]]:gpr(p0) = COPY $r0
   ; V5T:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V5T:   BLX [[COPY]](p0), csr_aapcs, implicit-def $lr, implicit $sp
-  ; V5T:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; V5T:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V5T:   BX_RET 14 /* CC::al */, $noreg
   ; THUMB-LABEL: name: test_indirect_call
   ; THUMB: bb.1.entry:
@@ -35,7 +35,7 @@
   ; THUMB:   [[COPY:%[0-9]+]]:gpr(p0) = COPY $r0
   ; THUMB:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; THUMB:   tBLXr 14 /* CC::al */, $noreg, [[COPY]](p0), csr_aapcs, implicit-def $lr, implicit $sp
-  ; THUMB:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; THUMB:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; THUMB:   tBX_RET 14 /* CC::al */, $noreg
 entry:
   notail call arm_aapcscc void %fptr()
@@ -49,25 +49,25 @@
   ; NOV4T: bb.1.entry:
   ; NOV4T:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; NOV4T:   BL @call_target, csr_aapcs, implicit-def $lr, implicit $sp
-  ; NOV4T:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; NOV4T:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; NOV4T:   MOVPCLR 14 /* CC::al */, $noreg
   ; V4T-LABEL: name: test_direct_call
   ; V4T: bb.1.entry:
   ; V4T:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V4T:   BL @call_target, csr_aapcs, implicit-def $lr, implicit $sp
-  ; V4T:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; V4T:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V4T:   BX_RET 14 /* CC::al */, $noreg
   ; V5T-LABEL: name: test_direct_call
   ; V5T: bb.1.entry:
   ; V5T:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V5T:   BL @call_target, csr_aapcs, implicit-def $lr, implicit $sp
-  ; V5T:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; V5T:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; V5T:   BX_RET 14 /* CC::al */, $noreg
   ; THUMB-LABEL: name: test_direct_call
   ; THUMB: bb.1.entry:
   ; THUMB:   ADJCALLSTACKDOWN 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; THUMB:   tBL 14 /* CC::al */, $noreg, @call_target, csr_aapcs, implicit-def $lr, implicit $sp
-  ; THUMB:   ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+  ; THUMB:   ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
   ; THUMB:   tBX_RET 14 /* CC::al */, $noreg
 entry:
   notail call arm_aapcscc void @call_target()
diff -ruN llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-param-lowering.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-param-lowering.ll
--- llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-param-lowering.ll	2023-05-24 11:35:48.316309820 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/GlobalISel/arm-param-lowering.ll	2022-02-01 09:13:46.451669313 -0500
@@ -14,7 +14,7 @@
 ; ARM: BL @simple_reg_params_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit-def $r0
 ; THUMB: tBL 14 /* CC::al */, $noreg, @simple_reg_params_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit-def $r0
 ; CHECK: [[RVREG:%[0-9]+]]:_(p0) = COPY $r0
-; CHECK: ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $r0 = COPY [[RVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $r0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $r0
@@ -45,7 +45,7 @@
 ; ARM: BL @simple_stack_params_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit-def $r0
 ; THUMB: tBL 14 /* CC::al */, $noreg, @simple_stack_params_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit-def $r0
 ; CHECK: [[RVREG:%[0-9]+]]:_(p0) = COPY $r0
-; CHECK: ADJCALLSTACKUP 8, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 8, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $r0 = COPY [[RVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $r0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $r0
@@ -103,7 +103,7 @@
 ; CHECK: [[R0VREG:%[0-9]+]]:_(s32) = COPY $r0
 ; CHECK: [[R0VREG_ASSERT:%[0-9]+]]:_(s32) = G_ASSERT_SEXT [[R0VREG]], 16
 ; CHECK: [[RVREG:%[0-9]+]]:_(s16) = G_TRUNC [[R0VREG_ASSERT]]
-; CHECK: ADJCALLSTACKUP 20, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 20, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: [[RExtVREG:%[0-9]+]]:_(s32) = G_SEXT [[RVREG]]
 ; CHECK: $r0 = COPY [[RExtVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $r0
@@ -125,7 +125,7 @@
 ; ARM: BL @vfpcc_fp_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $s0, implicit $d1, implicit-def $d0
 ; THUMB: tBL 14 /* CC::al */, $noreg, @vfpcc_fp_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $s0, implicit $d1, implicit-def $d0
 ; CHECK: [[RVREG:%[0-9]+]]:_(s64) = COPY $d0
-; CHECK: ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $d0 = COPY [[RVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $d0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $d0
@@ -164,7 +164,7 @@
 ; CHECK-DAG: [[R2:%[0-9]+]]:_(s32) = COPY $r1
 ; LITTLE: [[RVREG:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[R1]](s32), [[R2]](s32)
 ; BIG: [[RVREG:%[0-9]+]]:_(s64) = G_MERGE_VALUES [[R2]](s32), [[R1]](s32)
-; CHECK: ADJCALLSTACKUP 16, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 16, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: [[R1:%[0-9]+]]:_(s32), [[R2:%[0-9]+]]:_(s32) = G_UNMERGE_VALUES [[RVREG]](s64)
 ; LITTLE-DAG: $r0 = COPY [[R1]]
 ; LITTLE-DAG: $r1 = COPY [[R2]]
@@ -187,7 +187,7 @@
 ; ARM: BL @different_call_conv_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit-def $r0
 ; THUMB: tBL 14 /* CC::al */, $noreg, @different_call_conv_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit-def $r0
 ; CHECK: [[R:%[0-9]+]]:_(s32) = COPY $r0
-; CHECK: ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $s0 = COPY [[R]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $s0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $s0
@@ -211,7 +211,7 @@
 ; CHECK: [[R0:%[0-9]+]]:_(s32) = COPY $r0
 ; CHECK: [[R1:%[0-9]+]]:_(s32) = COPY $r1
 ; CHECK: [[R2:%[0-9]+]]:_(s32) = COPY $r2
-; CHECK: ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; FIXME: This doesn't seem correct with regard to the AAPCS docs (which say
 ; that composite types larger than 4 bytes should be passed through memory),
 ; but it's what DAGISel does. We should fix it in the common code for both.
@@ -241,7 +241,7 @@
 ; CHECK: $r3 = COPY [[R3]]
 ; ARM: BL @multiple_int_arrays_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3
 ; THUMB: tBL 14 /* CC::al */, $noreg, @multiple_int_arrays_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3
-; CHECK: ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; ARM: BX_RET 14 /* CC::al */, $noreg
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg
 entry:
@@ -284,7 +284,7 @@
 ; CHECK: G_STORE [[LAST_STACK_ELEMENT]](s32), [[LAST_STACK_ARG_ADDR]]{{.*}}store (s32)
 ; ARM: BL @large_int_arrays_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3
 ; THUMB: tBL 14 /* CC::al */, $noreg, @large_int_arrays_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3
-; CHECK: ADJCALLSTACKUP 64, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 64, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; ARM: BX_RET 14 /* CC::al */, $noreg
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg
 entry:
@@ -328,7 +328,7 @@
 ; THUMB: tBL 14 /* CC::al */, $noreg, @fp_arrays_aapcs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit-def $r0, implicit-def $r1
 ; CHECK: [[R0:%[0-9]+]]:_(s32) = COPY $r0
 ; CHECK: [[R1:%[0-9]+]]:_(s32) = COPY $r1
-; CHECK: ADJCALLSTACKUP 8, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 8, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $r0 = COPY [[R0]]
 ; CHECK: $r1 = COPY [[R1]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $r0, implicit $r1
@@ -391,7 +391,7 @@
 ; CHECK: [[R1:%[0-9]+]]:_(s32) = COPY $s1
 ; CHECK: [[R2:%[0-9]+]]:_(s32) = COPY $s2
 ; CHECK: [[R3:%[0-9]+]]:_(s32) = COPY $s3
-; CHECK: ADJCALLSTACKUP 32, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 32, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $s0 = COPY [[R0]]
 ; CHECK: $s1 = COPY [[R1]]
 ; CHECK: $s2 = COPY [[R2]]
@@ -440,7 +440,7 @@
 ; THUMB: tBL 14 /* CC::al */, $noreg, @tough_arrays_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit-def $r0, implicit-def $r1
 ; CHECK: [[R0:%[0-9]+]]:_(p0) = COPY $r0
 ; CHECK: [[R1:%[0-9]+]]:_(p0) = COPY $r1
-; CHECK: ADJCALLSTACKUP 80, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 80, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $r0 = COPY [[R0]]
 ; CHECK: $r1 = COPY [[R1]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $r0, implicit $r1
@@ -464,7 +464,7 @@
 ; THUMB: tBL 14 /* CC::al */, $noreg, @structs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit-def $r0, implicit-def $r1
 ; CHECK: [[R0:%[0-9]+]]:_(s32) = COPY $r0
 ; CHECK: [[R1:%[0-9]+]]:_(s32) = COPY $r1
-; CHECK: ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $r0 = COPY [[R0]](s32)
 ; CHECK: $r1 = COPY [[R1]](s32)
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $r0, implicit $r1
diff -ruN llvm-project/llvm/test/CodeGen/ARM/GlobalISel/irtranslator-varargs-lowering.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/GlobalISel/irtranslator-varargs-lowering.ll
--- llvm-project/llvm/test/CodeGen/ARM/GlobalISel/irtranslator-varargs-lowering.ll	2023-05-24 11:35:48.316309820 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/GlobalISel/irtranslator-varargs-lowering.ll	2022-02-01 09:13:46.451669313 -0500
@@ -23,7 +23,7 @@
 ; ARM: BL @int_varargs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit-def $r0
 ; THUMB: tBL 14 /* CC::al */, $noreg, @int_varargs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit $r3, implicit-def $r0
 ; CHECK: [[RVREG:%[0-9]+]]:_(s32) = COPY $r0
-; CHECK: ADJCALLSTACKUP 8, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 8, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $r0 = COPY [[RVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $r0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $r0
@@ -50,7 +50,7 @@
 ; ARM: BL @float_varargs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r2, implicit $r3, implicit-def $r0
 ; THUMB: tBL 14 /* CC::al */, $noreg, @float_varargs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r2, implicit $r3, implicit-def $r0
 ; CHECK: [[RVREG:%[0-9]+]]:_(s32) = COPY $r0
-; CHECK: ADJCALLSTACKUP 8, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 8, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $s0 = COPY [[RVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $s0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $s0
@@ -71,7 +71,7 @@
 ; ARM: BL @float_varargs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r2, implicit $r3, implicit-def $r0
 ; THUMB: tBL 14 /* CC::al */, $noreg, @float_varargs_target, csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r2, implicit $r3, implicit-def $r0
 ; CHECK: [[RVREG:%[0-9]+]]:_(s32) = COPY $r0
-; CHECK: ADJCALLSTACKUP 0, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 0, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $s0 = COPY [[RVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $s0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $s0
@@ -97,7 +97,7 @@
 ; ARM: BLX [[FPTRVREG]](p0), csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r2, implicit $r3, implicit-def $r0
 ; THUMB: tBLXr 14 /* CC::al */, $noreg, [[FPTRVREG]](p0), csr_aapcs, implicit-def $lr, implicit $sp, implicit $r0, implicit $r2, implicit $r3, implicit-def $r0
 ; CHECK: [[RVREG:%[0-9]+]]:_(s32) = COPY $r0
-; CHECK: ADJCALLSTACKUP 8, 0, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
+; CHECK: ADJCALLSTACKUP 8, -1, 14 /* CC::al */, $noreg, implicit-def $sp, implicit $sp
 ; CHECK: $s0 = COPY [[RVREG]]
 ; ARM: BX_RET 14 /* CC::al */, $noreg, implicit $s0
 ; THUMB: tBX_RET 14 /* CC::al */, $noreg, implicit $s0
diff -ruN llvm-project/llvm/test/CodeGen/ARM/readtp.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/readtp.ll
--- llvm-project/llvm/test/CodeGen/ARM/readtp.ll	2023-05-24 11:35:48.348310165 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/readtp.ll	2022-02-01 09:13:46.451669313 -0500
@@ -1,5 +1,7 @@
 ; RUN: llc -mtriple=armeb-linux-gnueabihf -O2 -mattr=+read-tp-hard %s -o - | FileCheck %s -check-prefix=CHECK-HARD
 ; RUN: llc -mtriple=armeb-linux-gnueabihf -O2 %s -o - | FileCheck %s -check-prefix=CHECK-SOFT
+; RUN: llc -mtriple=thumbv7-linux-gnueabihf -O2 -mattr=+read-tp-hard %s -o - | FileCheck %s -check-prefix=CHECK-HARD
+; RUN: llc -mtriple=thumbv7-linux-gnueabihf -O2 %s -o - | FileCheck %s -check-prefix=CHECK-SOFT
 
 
 ; __thread int counter;
diff -ruN llvm-project/llvm/test/CodeGen/ARM/shifter_operand.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/shifter_operand.ll
--- llvm-project/llvm/test/CodeGen/ARM/shifter_operand.ll	2023-05-24 11:35:48.348310165 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/shifter_operand.ll	2022-02-01 09:13:46.451669313 -0500
@@ -256,3 +256,108 @@
 
   ret { i32, i32 } %ret
 }
+
+define i32 @test_new(i32 %x, i32 %y) {
+; CHECK-ARM-LABEL: test_new:
+; CHECK-ARM:       @ %bb.0: @ %entry
+; CHECK-ARM-NEXT:    movw r2, #48047
+; CHECK-ARM-NEXT:    mul r1, r1, r2
+; CHECK-ARM-NEXT:    add r0, r0, r1, lsl #1
+; CHECK-ARM-NEXT:    bx lr
+;
+; CHECK-THUMB-LABEL: test_new:
+; CHECK-THUMB:       @ %bb.0: @ %entry
+; CHECK-THUMB-NEXT:    movw r2, #48047
+; CHECK-THUMB-NEXT:    muls r1, r2, r1
+; CHECK-THUMB-NEXT:    add.w r0, r0, r1, lsl #1
+; CHECK-THUMB-NEXT:    bx lr
+entry:
+  %mul = mul i32 %y, 96094
+  %conv = add i32 %mul, %x
+  ret i32 %conv
+}
+
+; This test was hitting issues with deleted nodes because ComplexPatternFuncMutatesDAG
+; was not defined.
+@arr_9 = external dso_local local_unnamed_addr global [15 x [25 x [18 x i8]]], align 1
+define void @test_mutateddag(i32 %b, i32 %c, i32 %d, i1 %cc) {
+; CHECK-THUMB-LABEL: test_mutateddag:
+; CHECK-THUMB:       @ %bb.0: @ %entry
+; CHECK-THUMB-NEXT:    .save {r4, lr}
+; CHECK-THUMB-NEXT:    push {r4, lr}
+; CHECK-THUMB-NEXT:    movw r12, #50608
+; CHECK-THUMB-NEXT:    movw r4, #51512
+; CHECK-THUMB-NEXT:    movt r12, #17917
+; CHECK-THUMB-NEXT:    movt r4, #52
+; CHECK-THUMB-NEXT:    mla r12, r1, r4, r12
+; CHECK-THUMB-NEXT:    mov.w r4, #450
+; CHECK-THUMB-NEXT:    lsls r3, r3, #31
+; CHECK-THUMB-NEXT:    mul lr, r0, r4
+; CHECK-THUMB-NEXT:    movw r0, #48047
+; CHECK-THUMB-NEXT:    muls r0, r1, r0
+; CHECK-THUMB-NEXT:    movw r1, :lower16:arr_9
+; CHECK-THUMB-NEXT:    movt r1, :upper16:arr_9
+; CHECK-THUMB-NEXT:    add.w r0, r2, r0, lsl #1
+; CHECK-THUMB-NEXT:    movw r2, #24420
+; CHECK-THUMB-NEXT:    movt r2, #19356
+; CHECK-THUMB-NEXT:    add.w r0, r0, r0, lsl #3
+; CHECK-THUMB-NEXT:    add.w r0, r1, r0, lsl #1
+; CHECK-THUMB-NEXT:    movw r1, #60920
+; CHECK-THUMB-NEXT:    movt r1, #64028
+; CHECK-THUMB-NEXT:    add r2, r0
+; CHECK-THUMB-NEXT:    add r1, r0
+; CHECK-THUMB-NEXT:    movs r0, #0
+; CHECK-THUMB-NEXT:    b .LBB19_2
+; CHECK-THUMB-NEXT:  .LBB19_1: @ %for.cond1.for.cond.cleanup_crit_edge
+; CHECK-THUMB-NEXT:    @ in Loop: Header=BB19_2 Depth=1
+; CHECK-THUMB-NEXT:    add r1, lr
+; CHECK-THUMB-NEXT:    add r2, lr
+; CHECK-THUMB-NEXT:  .LBB19_2: @ %for.cond
+; CHECK-THUMB-NEXT:    @ =>This Loop Header: Depth=1
+; CHECK-THUMB-NEXT:    @ Child Loop BB19_3 Depth 2
+; CHECK-THUMB-NEXT:    movs r4, #0
+; CHECK-THUMB-NEXT:  .LBB19_3: @ %for.cond2.preheader
+; CHECK-THUMB-NEXT:    @ Parent Loop BB19_2 Depth=1
+; CHECK-THUMB-NEXT:    @ => This Inner Loop Header: Depth=2
+; CHECK-THUMB-NEXT:    cmp r3, #0
+; CHECK-THUMB-NEXT:    str r0, [r1, r4]
+; CHECK-THUMB-NEXT:    bne .LBB19_1
+; CHECK-THUMB-NEXT:  @ %bb.4: @ %for.cond2.preheader.2
+; CHECK-THUMB-NEXT:    @ in Loop: Header=BB19_3 Depth=2
+; CHECK-THUMB-NEXT:    str r0, [r2, r4]
+; CHECK-THUMB-NEXT:    add r4, r12
+; CHECK-THUMB-NEXT:    b .LBB19_3
+entry:
+  %0 = add i32 %d, -4
+  %1 = mul i32 %c, 864846
+  %2 = add i32 %1, 1367306604
+  br label %for.cond
+
+for.cond:                                         ; preds = %for.cond1.for.cond.cleanup_crit_edge, %for.cond.preheader
+  %indvar = phi i32 [ 0, %entry ], [ %indvar.next, %for.cond1.for.cond.cleanup_crit_edge ]
+  %3 = mul i32 %indvar, %b
+  %4 = add i32 %3, -2
+  br label %for.cond2.preheader
+
+for.cond2.preheader:                              ; preds = %for.cond2.preheader.2, %for.cond
+  %indvar24 = phi i32 [ 0, %for.cond ], [ %indvar.next25.3, %for.cond2.preheader.2 ]
+  %indvar.next25 = or i32 %indvar24, 1
+  %l5 = mul i32 %2, %indvar.next25
+  %scevgep.1 = getelementptr [15 x [25 x [18 x i8]]], [15 x [25 x [18 x i8]]]* @arr_9, i32 -217196, i32 %4, i32 %0, i32 %l5
+  %l7 = bitcast i8* %scevgep.1 to i32*
+  store i32 0, i32* %l7, align 1
+  br i1 %cc, label %for.cond1.for.cond.cleanup_crit_edge, label %for.cond2.preheader.2
+
+for.cond2.preheader.2:                            ; preds = %for.cond2.preheader
+  %indvar.next25.1 = or i32 %indvar24, 2
+  %l8 = mul i32 %2, %indvar.next25.1
+  %scevgep.2 = getelementptr [15 x [25 x [18 x i8]]], [15 x [25 x [18 x i8]]]* @arr_9, i32 -217196, i32 %4, i32 %0, i32 %l8
+  %l10 = bitcast i8* %scevgep.2 to i32*
+  store i32 0, i32* %l10, align 1
+  %indvar.next25.3 = add i32 %indvar24, 4
+  br label %for.cond2.preheader
+
+for.cond1.for.cond.cleanup_crit_edge:             ; preds = %for.cond2.preheader
+  %indvar.next = add i32 %indvar, 1
+  br label %for.cond
+}
diff -ruN llvm-project/llvm/test/CodeGen/ARM/thread_pointer.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/thread_pointer.ll
--- llvm-project/llvm/test/CodeGen/ARM/thread_pointer.ll	2023-05-24 11:35:48.352310207 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/ARM/thread_pointer.ll	2022-02-01 09:13:46.451669313 -0500
@@ -1,4 +1,7 @@
-; RUN: llc -mtriple arm-linux-gnueabi -filetype asm -o - %s | FileCheck %s
+; RUN: llc -mtriple arm-linux-gnueabi -o - %s | FileCheck %s -check-prefix=CHECK-SOFT
+; RUN: llc -mtriple arm-linux-gnueabi -mattr=+read-tp-hard -o - %s | FileCheck %s -check-prefix=CHECK-HARD
+; RUN: llc -mtriple thumbv7-linux-gnueabi -o - %s | FileCheck %s -check-prefix=CHECK-SOFT
+; RUN: llc -mtriple thumbv7-linux-gnueabi -mattr=+read-tp-hard -o - %s | FileCheck %s -check-prefix=CHECK-HARD
 
 declare i8* @llvm.thread.pointer()
 
@@ -8,5 +11,6 @@
   ret i8* %tmp1
 }
 
-; CHECK: bl __aeabi_read_tp
+; CHECK-SOFT: bl __aeabi_read_tp
+; CHECK-HARD: mrc p15, #0, {{r[0-9]+}}, c13, c0, #3
 
diff -ruN llvm-project/llvm/test/CodeGen/Mips/tls-static.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/Mips/tls-static.ll
--- llvm-project/llvm/test/CodeGen/Mips/tls-static.ll	2023-05-24 11:35:48.464311416 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/Mips/tls-static.ll	2022-02-01 09:13:46.451669313 -0500
@@ -50,16 +50,16 @@
 ; STATIC32-LABEL:   f2:
 ; STATIC32:   lui     $[[R0:[0-9]+]], %hi(__gnu_local_gp)
 ; STATIC32:   addiu   $[[GP:[0-9]+]], $[[R0]], %lo(__gnu_local_gp)
-; STATIC32:   rdhwr   $3, $29{{$}}
 ; STATIC32:   lw      $[[R0:[0-9]+]], %gottprel(t2)($[[GP]])
+; STATIC32:   rdhwr   $3, $29{{$}}
 ; STATIC32:   addu    $[[R1:[0-9]+]], $3, $[[R0]]
 ; STATIC32:   lw      $2, 0($[[R1]])
 
 ; STATIC64-LABEL:   f2:
 ; STATIC64:   lui     $[[R0:[0-9]+]], %hi(%neg(%gp_rel(f2)))
 ; STATIC64:   daddiu  $[[GP:[0-9]+]], $[[R0]], %lo(%neg(%gp_rel(f2)))
-; STATIC64:   rdhwr   $3, $29{{$}}
 ; STATIC64:   ld      $[[R0:[0-9]+]], %gottprel(t2)($[[GP]])
+; STATIC64:   rdhwr   $3, $29{{$}}
 ; STATIC64:   daddu   $[[R1:[0-9]+]], $3, $[[R0]]
 ; STATIC64:   lw      $2, 0($[[R1]])
 }
diff -ruN llvm-project/llvm/test/CodeGen/PowerPC/inline-asm-label.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/PowerPC/inline-asm-label.ll
--- llvm-project/llvm/test/CodeGen/PowerPC/inline-asm-label.ll	2023-05-24 11:35:48.496311762 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/PowerPC/inline-asm-label.ll	2022-02-01 09:13:46.451669313 -0500
@@ -45,3 +45,39 @@
   ret i32 %4
 }
 
+define dso_local signext i32 @NoBarrier_CompareAndSwapExtMne(i32* %ptr, i32 signext %old_value, i32 signext %new_value) #0 {
+; CHECK-LABEL: NoBarrier_CompareAndSwapExtMne:
+; CHECK:    #APP
+; CHECK-NEXT:  L..tmp2:
+; CHECK-NEXT:    lwarx 6, 0, 3
+; CHECK-NEXT:    cmpw 4, 6
+; CHECK-NEXT:    bne- 0, L..tmp3
+; CHECK-NEXT:    stwcx. 5, 0, 3
+; CHECK-NEXT:    bne- 0, L..tmp2
+; CHECK-NEXT:  L..tmp3:
+
+; NOIS-LABEL: NoBarrier_CompareAndSwapExtMne:
+; NOIS:    #APP
+; NOIS-NEXT: 1: lwarx 6, 0, 3
+; NOIS-NEXT:    cmpw 4, 6
+; NOIS-NEXT:    bne- 2f
+; NOIS-NEXT:    stwcx. 5, 0, 3
+; NOIS-NEXT:    bne- 1b
+; NOIS-NEXT: 2:
+
+entry:
+  %ptr.addr = alloca i32*, align 8                                                                                                                                            %old_value.addr = alloca i32, align 4
+  %new_value.addr = alloca i32, align 4
+  %result = alloca i32, align 4
+  store i32* %ptr, i32** %ptr.addr, align 8
+  store i32 %old_value, i32* %old_value.addr, align 4
+  store i32 %new_value, i32* %new_value.addr, align 4
+  %0 = load i32*, i32** %ptr.addr, align 8
+  %1 = load i32, i32* %old_value.addr, align 4
+  %2 = load i32, i32* %new_value.addr, align 4
+  %3 = call i32 asm sideeffect "1:     lwarx $0, $4, $1, 0   \0A\09       cmpw $2, $0             \0A\09       bne- 2f                         \0A\09       stwcx. $3, $4, $1  \0A\09       bne- 1b                         \0A\092:                                     \0A\09", "=&b,b,b,b,i,~{cr0},~{ctr}"(i32* %0, i32 %1, i32 %2, i32 0)
+  store i32 %3, i32* %result, align 4
+  %4 = load i32, i32* %result, align 4
+  ret i32 %4
+}
+
diff -ruN llvm-project/llvm/test/CodeGen/RISCV/machine-outliner-patchable.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/RISCV/machine-outliner-patchable.ll
--- llvm-project/llvm/test/CodeGen/RISCV/machine-outliner-patchable.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/RISCV/machine-outliner-patchable.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,77 @@
+; RUN: llc < %s -verify-machineinstrs -enable-machine-outliner | FileCheck %s
+
+target triple = "riscv64-unknown-linux-gnu"
+
+declare void @foo(i32, i32, i32, i32) minsize
+
+;; TargetOpcode::FENTRY_CALL at the start of the function expands to a __fentry__
+;; call which must be present. Don't outline it.
+define void @fentry0(i1 %a) nounwind "fentry-call"="true" {
+; CHECK-LABEL: fentry0:
+; CHECK-NEXT:  # %bb.0:
+; CHECK-NEXT:    # FEntry call
+; CHECK:       # %bb.1:
+; CHECK-NEXT:    call t0, OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+define void @fentry1(i1 %a) nounwind "fentry-call"="true" {
+; CHECK-LABEL: fentry1:
+; CHECK-NEXT:  # %bb.0:
+; CHECK-NEXT:    # FEntry call
+; CHECK:       # %bb.1:
+; CHECK-NEXT:    call t0, OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+;; TargetOpcode::PATCHABLE_FUNCTION_ENTER at the start of the function expands to
+;; NOPs which must be present. Don't outline them.
+define void @patchable0(i1 %a) nounwind "patchable-function-entry"="2" {
+; CHECK-LABEL: patchable0:
+; CHECK-NEXT:  .Lfunc_begin0:
+; CHECK-NEXT:  # %bb.0:
+; CHECK-NEXT:    nop
+; CHECK-NEXT:    nop
+; CHECK:       # %bb.1:
+; CHECK-NEXT:    call t0, OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
+
+define void @patchable1(i1 %a) nounwind "patchable-function-entry"="2" {
+; CHECK-LABEL: patchable1:
+; CHECK-NEXT:  .Lfunc_begin1:
+; CHECK-NEXT:  # %bb.0:
+; CHECK-NEXT:    nop
+; CHECK-NEXT:    nop
+; CHECK:       # %bb.1:
+; CHECK-NEXT:    call t0, OUTLINED_FUNCTION_1
+entry:
+  br i1 %a, label %if.then, label %if.end
+if.then:
+  call void @foo(i32 1, i32 2, i32 3, i32 4)
+  br label %if.end
+if.end:
+  call void @foo(i32 5, i32 6, i32 7, i32 8)
+  ret void
+}
diff -ruN llvm-project/llvm/test/CodeGen/RISCV/nfu.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/RISCV/nfu.ll
--- llvm-project/llvm/test/CodeGen/RISCV/nfu.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/RISCV/nfu.ll	2023-03-27 23:00:32.815404042 -0400
@@ -0,0 +1,10 @@
+; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
+; RUN: | FileCheck %s -check-prefix=NFU
+
+declare void @llvm.exec.nfu(i32 immarg, i32 immarg)
+
+define i32 @test_exec_nfu(i32 %a) nounwind {
+   %1 = xor i32 %a, -1
+   call void @llvm.exec.nfu(i32 0, i32 0)
+   ret i32 0
+}
Binary files llvm-project/llvm/test/CodeGen/RISCV/nfu.o and /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/RISCV/nfu.o differ
diff -ruN llvm-project/llvm/test/CodeGen/RISCV/test.s /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/RISCV/test.s
--- llvm-project/llvm/test/CodeGen/RISCV/test.s	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/RISCV/test.s	2023-03-27 22:59:30.618815940 -0400
@@ -0,0 +1,23 @@
+	.text
+	.attribute	4, 16
+	.attribute	5, "rv64i2p0"
+	.file	"nfu.ll"
+	.globl	test_exec_nfu                   # -- Begin function test_exec_nfu
+	.p2align	2
+	.type	test_exec_nfu,@function
+test_exec_nfu:                          # @test_exec_nfu
+# %bb.0:
+	addi	sp, sp, -16
+	sd	ra, 8(sp)                       # 8-byte Folded Spill
+	mv	a1, zero
+	sd	a1, 0(sp)                       # 8-byte Folded Spill
+	mv	a0, a1
+	call	llvm.exec_nfu@plt
+	ld	a0, 0(sp)                       # 8-byte Folded Reload
+	ld	ra, 8(sp)                       # 8-byte Folded Reload
+	addi	sp, sp, 16
+	ret
+.Lfunc_end0:
+	.size	test_exec_nfu, .Lfunc_end0-test_exec_nfu
+                                        # -- End function
+	.section	".note.GNU-stack","",@progbits
diff -ruN llvm-project/llvm/test/CodeGen/X86/dwarf-eh-prepare.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/X86/dwarf-eh-prepare.ll
--- llvm-project/llvm/test/CodeGen/X86/dwarf-eh-prepare.ll	2023-05-24 11:35:48.916316296 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/X86/dwarf-eh-prepare.ll	2022-02-01 09:13:46.451669313 -0500
@@ -1,4 +1,4 @@
-; RUN: opt -mtriple=x86_64-linux-gnu -dwarfehprepare -simplifycfg-require-and-preserve-domtree=1 < %s -S | FileCheck %s
+; RUN: opt -mtriple=x86_64-linux-gnu -dwarfehprepare -simplifycfg-require-and-preserve-domtree=1 -run-twice < %s -S | FileCheck %s
 
 ; Check basic functionality of IR-to-IR DWARF EH preparation. This should
 ; eliminate resumes. This pass requires a TargetMachine, so we put it under X86
diff -ruN llvm-project/llvm/test/CodeGen/X86/horizontal-shuffle-2.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/X86/horizontal-shuffle-2.ll
--- llvm-project/llvm/test/CodeGen/X86/horizontal-shuffle-2.ll	2023-05-24 11:35:48.944316598 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/X86/horizontal-shuffle-2.ll	2022-02-01 09:13:46.451669313 -0500
@@ -171,6 +171,25 @@
   ret <4 x float> %3
 }
 
+define <8 x i16> @PR51974(<8 x i16> %a0) {
+; SSE-LABEL: PR51974:
+; SSE:       ## %bb.0:
+; SSE-NEXT:    movdqa %xmm0, %xmm1
+; SSE-NEXT:    phaddw %xmm0, %xmm1
+; SSE-NEXT:    phaddw %xmm0, %xmm1
+; SSE-NEXT:    movdqa %xmm1, %xmm0
+; SSE-NEXT:    ret{{[l|q]}}
+;
+; AVX-LABEL: PR51974:
+; AVX:       ## %bb.0:
+; AVX-NEXT:    vphaddw %xmm0, %xmm0, %xmm1
+; AVX-NEXT:    vphaddw %xmm0, %xmm1, %xmm0
+; AVX-NEXT:    ret{{[l|q]}}
+  %r0 = call <8 x i16> @llvm.x86.ssse3.phadd.w.128(<8 x i16> %a0, <8 x i16> %a0)
+  %r1 = call <8 x i16> @llvm.x86.ssse3.phadd.w.128(<8 x i16> %r0, <8 x i16> %a0)
+  ret <8 x i16> %r1
+}
+
 declare <4 x float> @llvm.x86.sse3.hadd.ps(<4 x float>, <4 x float>)
 declare <4 x float> @llvm.x86.sse3.hsub.ps(<4 x float>, <4 x float>)
 declare <2 x double> @llvm.x86.sse3.hadd.pd(<2 x double>, <2 x double>)
diff -ruN llvm-project/llvm/test/CodeGen/X86/vaargs-prolog-insert.ll /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/X86/vaargs-prolog-insert.ll
--- llvm-project/llvm/test/CodeGen/X86/vaargs-prolog-insert.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/CodeGen/X86/vaargs-prolog-insert.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,45 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=x86_64 < %s | FileCheck %s
+
+; Check the prolog won't be sunk across the save of CSRs.
+define void @reduce(i32, i32, i32, i32, i32, i32, ...) nounwind {
+; CHECK-LABEL: reduce:
+; CHECK:       # %bb.0:
+; CHECK-NEXT:    subq $56, %rsp
+; CHECK-NEXT:    testb %al, %al
+; CHECK-NEXT:    je .LBB0_4
+; CHECK-NEXT:  # %bb.3:
+; CHECK-NEXT:    movaps %xmm0, -{{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movaps %xmm1, -{{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movaps %xmm2, -{{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movaps %xmm3, -{{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movaps %xmm4, -{{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movaps %xmm5, (%rsp)
+; CHECK-NEXT:    movaps %xmm6, {{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movaps %xmm7, {{[0-9]+}}(%rsp)
+; CHECK-NEXT:  .LBB0_4:
+; CHECK-NEXT:    xorl %eax, %eax
+; CHECK-NEXT:    testb %al, %al
+; CHECK-NEXT:    jne .LBB0_2
+; CHECK-NEXT:  # %bb.1:
+; CHECK-NEXT:    leaq -{{[0-9]+}}(%rsp), %rax
+; CHECK-NEXT:    movq %rax, 16
+; CHECK-NEXT:    leaq {{[0-9]+}}(%rsp), %rax
+; CHECK-NEXT:    movq %rax, 8
+; CHECK-NEXT:    movl $48, 4
+; CHECK-NEXT:    movl $48, 0
+; CHECK-NEXT:  .LBB0_2:
+; CHECK-NEXT:    addq $56, %rsp
+; CHECK-NEXT:    retq
+  br i1 undef, label %8, label %7
+
+7:                                                ; preds = %6
+  call void @llvm.va_start(i8* null)
+  br label %8
+
+8:                                                ; preds = %7, %6
+  ret void
+}
+
+declare void @llvm.va_start(i8*)
+declare void @llvm.va_end(i8*)
diff -ruN llvm-project/llvm/test/JitListener/multiple.ll /home/dtrilla/git/novia/llvm-project/llvm/test/JitListener/multiple.ll
--- llvm-project/llvm/test/JitListener/multiple.ll	2023-05-24 11:35:49.240319793 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/JitListener/multiple.ll	2022-02-01 09:13:46.451669313 -0500
@@ -26,16 +26,16 @@
 ; 21: }
 ;
 
-; CHECK: Method load [1]: bar, Size = {{[0-9]+}}
+; CHECK: Method load [1]: foo, Size = {{[0-9]+}}
+; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[1,2]}}
+; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[1,2]}}
+
+; CHECK: Method load [2]: bar, Size = {{[0-9]+}}
 ; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[5,6,7,9]}}
 ; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[5,6,7,9]}}
 ; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[5,6,7,9]}}
 ; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[5,6,7,9]}}
 
-; CHECK: Method load [2]: foo, Size = {{[0-9]+}}
-; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[1,2]}}
-; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[1,2]}}
-
 ; CHECK: Method load [3]: fubar, Size = {{[0-9]+}}
 ; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[12,13,15,17,19]}}
 ; CHECK:   Line info @ {{[0-9]+}}: multiple.c, line {{[12,13,15,17,19]}}
diff -ruN llvm-project/llvm/test/MC/ELF/section-omitted-attributes.s /home/dtrilla/git/novia/llvm-project/llvm/test/MC/ELF/section-omitted-attributes.s
--- llvm-project/llvm/test/MC/ELF/section-omitted-attributes.s	2023-05-24 11:35:49.420321736 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/MC/ELF/section-omitted-attributes.s	2022-02-01 09:13:46.451669313 -0500
@@ -4,6 +4,7 @@
 
 # CHECK: .section        .foo,"aM",@progbits,1
 # CHECK: .section        .rodata.cst8,"aM",@progbits,8
+# CHECK: .section        .lds_bss,"w",@nobits
 
 .section .foo,"aM",@progbits,1
 
@@ -15,3 +16,7 @@
 .section .rodata.cst8,"aM",@progbits,8
 
 .section .rodata.cst8
+
+# Likewise for Type changes
+.section        .lds_bss,"w",@nobits
+.section        .lds_bss
diff -ruN llvm-project/llvm/test/MC/Mips/elf-debug-section.s /home/dtrilla/git/novia/llvm-project/llvm/test/MC/Mips/elf-debug-section.s
--- llvm-project/llvm/test/MC/Mips/elf-debug-section.s	2023-05-24 11:35:49.432321866 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/MC/Mips/elf-debug-section.s	2022-02-01 09:13:46.451669313 -0500
@@ -1,6 +1,42 @@
 # RUN: llvm-mc -filetype=obj -triple=mips-linux-gnu -g %s -o - \
 # RUN:   | llvm-readobj -S - | FileCheck %s
 
+# MIPS .debug_* sections should have SHT_MIPS_DWARF section type
+# to distinguish among sections contain DWARF and ECOFF debug formats,
+# but in assembly files these sections have SHT_PROGBITS type.
+
+.section        .debug_abbrev,"",@progbits
+.section        .debug_addr,"",@progbits
+.section        .debug_aranges,"",@progbits
+.section        .debug_info,"",@progbits
+.section        .debug_line,"",@progbits
+.section        .debug_loclists,"",@progbits
+.section        .debug_pubnames,"",@progbits
+.section        .debug_pubtypes,"",@progbits
+.section        .debug_ranges,"",@progbits
+.section        .debug_rnglists,"",@progbits
+.section        .debug_str,"MS",@progbits,1
+
 # CHECK:      Section {
+# CHECK:        Name: .debug_abbrev
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_addr
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_aranges
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_info
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
 # CHECK:        Name: .debug_line
-# CHECK-NEXT:   Type: SHT_MIPS_DWARF (0x7000001E)
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_loclists
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_pubnames
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_pubtypes
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_ranges
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_rnglists
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
+# CHECK:        Name: .debug_str
+# CHECK-NEXT:   Type: SHT_MIPS_DWARF
diff -ruN llvm-project/llvm/test/MC/PowerPC/ppc64-encoding-bookII.s /home/dtrilla/git/novia/llvm-project/llvm/test/MC/PowerPC/ppc64-encoding-bookII.s
--- llvm-project/llvm/test/MC/PowerPC/ppc64-encoding-bookII.s	2023-05-24 11:35:49.448322038 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/MC/PowerPC/ppc64-encoding-bookII.s	2022-02-01 09:13:46.451669313 -0500
@@ -130,18 +130,34 @@
 # CHECK-LE: lbarx 2, 3, 4                   # encoding: [0x68,0x20,0x43,0x7c]
             lbarx 2, 3, 4
 
+# CHECK-BE: lbarx 2, 3, 4                   # encoding: [0x7c,0x43,0x20,0x68]
+# CHECK-LE: lbarx 2, 3, 4                   # encoding: [0x68,0x20,0x43,0x7c]
+            lbarx 2, 3, 4, 0
+
 # CHECK-BE: lharx 2, 3, 4                   # encoding: [0x7c,0x43,0x20,0xe8]
 # CHECK-LE: lharx 2, 3, 4                   # encoding: [0xe8,0x20,0x43,0x7c]
             lharx 2, 3, 4
 
+# CHECK-BE: lharx 2, 3, 4                   # encoding: [0x7c,0x43,0x20,0xe8]
+# CHECK-LE: lharx 2, 3, 4                   # encoding: [0xe8,0x20,0x43,0x7c]
+            lharx 2, 3, 4, 0
+
 # CHECK-BE: lwarx 2, 3, 4                   # encoding: [0x7c,0x43,0x20,0x28]
 # CHECK-LE: lwarx 2, 3, 4                   # encoding: [0x28,0x20,0x43,0x7c]
             lwarx 2, 3, 4
 
+# CHECK-BE: lwarx 2, 3, 4                   # encoding: [0x7c,0x43,0x20,0x28]
+# CHECK-LE: lwarx 2, 3, 4                   # encoding: [0x28,0x20,0x43,0x7c]
+            lwarx 2, 3, 4, 0
+
 # CHECK-BE: ldarx 2, 3, 4                   # encoding: [0x7c,0x43,0x20,0xa8]
 # CHECK-LE: ldarx 2, 3, 4                   # encoding: [0xa8,0x20,0x43,0x7c]
             ldarx 2, 3, 4
 
+# CHECK-BE: ldarx 2, 3, 4                   # encoding: [0x7c,0x43,0x20,0xa8]
+# CHECK-LE: ldarx 2, 3, 4                   # encoding: [0xa8,0x20,0x43,0x7c]
+            ldarx 2, 3, 4, 0
+
 # CHECK-BE: lqarx 2, 3, 4                   # encoding: [0x7c,0x43,0x22,0x28]
 # CHECK-LE: lqarx 2, 3, 4                   # encoding: [0x28,0x22,0x43,0x7c]
             lqarx 2, 3, 4
diff -ruN llvm-project/llvm/test/MC/PowerPC/ppc64-errors.s /home/dtrilla/git/novia/llvm-project/llvm/test/MC/PowerPC/ppc64-errors.s
--- llvm-project/llvm/test/MC/PowerPC/ppc64-errors.s	2023-05-24 11:35:49.448322038 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/MC/PowerPC/ppc64-errors.s	2022-02-01 09:13:46.451669313 -0500
@@ -139,3 +139,7 @@
 # CHECK: error: invalid modifier 'got' (no symbols present)
          addi 4, 3, 123@got
 # CHECK-NEXT: addi 4, 3, 123@got
+
+# CHECK: error: invalid operand for instruction
+# CHECK-NEXT: lwarx 1, 2, 3, a
+              lwarx 1, 2, 3, a
diff -ruN llvm-project/llvm/test/MC/RISCV/nfu.s /home/dtrilla/git/novia/llvm-project/llvm/test/MC/RISCV/nfu.s
--- llvm-project/llvm/test/MC/RISCV/nfu.s	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/MC/RISCV/nfu.s	2021-09-06 09:46:57.254805192 -0400
@@ -0,0 +1,13 @@
+# RUN: llvm-mc %s -triple=riscv64 -show-encoding \
+# RUN: | FileCheck -check-prefixes=CHECK,CHECK-INST %s
+# RUN: llvm-mc -filetype=obj -triple riscv64  < %s \
+# RUN: | llvm-objdump -d - \
+# RUN: | FileCheck -check-prefix=CHECK-INST %s
+exec_nfu 0,0
+
+# CHECK-INST: exec_nfu 0, 0
+# CHECK: encoding: [0xdb,0x00,0x00,0x00]
+exec_nfu 0,0
+# CHECK-INST: exec_nfu 2, 1
+# CHECK: encoding: [0xdb,0x88,0x00,0x00]
+exec_nfu 2,1
diff -ruN llvm-project/llvm/test/MC/X86/padlock.s /home/dtrilla/git/novia/llvm-project/llvm/test/MC/X86/padlock.s
--- llvm-project/llvm/test/MC/X86/padlock.s	2023-05-24 11:35:49.496322557 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/MC/X86/padlock.s	2022-02-01 09:13:46.451669313 -0500
@@ -1,5 +1,32 @@
 // RUN: llvm-mc -triple i386-unknown-unknown --show-encoding %s | FileCheck %s
 
+/// Check xstore does not get an implicit REP prefix but all other PadLock
+/// instructions do.
+
 	xstore
 // CHECK: xstore
-// CHECK: encoding: [0xf3,0x0f,0xa7,0xc0]
+// CHECK: encoding: [0x0f,0xa7,0xc0]
+	xcryptecb
+// CHECK: xcryptecb
+// CHECK: encoding: [0xf3,0x0f,0xa7,0xc8]
+	xcryptcbc
+// CHECK: xcryptcbc
+// CHECK: encoding: [0xf3,0x0f,0xa7,0xd0]
+	xcryptctr
+// CHECK: xcryptctr
+// CHECK: encoding: [0xf3,0x0f,0xa7,0xd8]
+	xcryptcfb
+// CHECK: xcryptcfb
+// CHECK: encoding: [0xf3,0x0f,0xa7,0xe0]
+	xcryptofb
+// CHECK: xcryptofb
+// CHECK: encoding: [0xf3,0x0f,0xa7,0xe8]
+	xsha1
+// CHECK: xsha1
+// CHECK: encoding: [0xf3,0x0f,0xa6,0xc8]
+	xsha256
+// CHECK: xsha256
+// CHECK: encoding: [0xf3,0x0f,0xa6,0xd0]
+	montmul
+// CHECK: montmul
+// CHECK: encoding: [0xf3,0x0f,0xa6,0xc0]
diff -ruN llvm-project/llvm/test/Transforms/Attributor/IPConstantProp/dangling-block-address.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Attributor/IPConstantProp/dangling-block-address.ll
--- llvm-project/llvm/test/Transforms/Attributor/IPConstantProp/dangling-block-address.ll	2023-05-24 11:35:49.548323118 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Attributor/IPConstantProp/dangling-block-address.ll	2022-02-01 09:13:46.451669313 -0500
@@ -34,37 +34,23 @@
 }
 
 define internal void @bar(i32* nocapture %pc) nounwind readonly {
-; IS__CGSCC_OPM: Function Attrs: nounwind readonly
-; IS__CGSCC_OPM-LABEL: define {{[^@]+}}@bar
-; IS__CGSCC_OPM-SAME: (i32* nocapture [[PC:%.*]]) #[[ATTR1:[0-9]+]] {
-; IS__CGSCC_OPM-NEXT:  entry:
-; IS__CGSCC_OPM-NEXT:    br label [[INDIRECTGOTO:%.*]]
-; IS__CGSCC_OPM:       lab0:
-; IS__CGSCC_OPM-NEXT:    [[INDVAR_NEXT:%.*]] = add i32 [[INDVAR:%.*]], 1
-; IS__CGSCC_OPM-NEXT:    br label [[INDIRECTGOTO]]
-; IS__CGSCC_OPM:       end:
-; IS__CGSCC_OPM-NEXT:    ret void
-; IS__CGSCC_OPM:       indirectgoto:
-; IS__CGSCC_OPM-NEXT:    [[INDVAR]] = phi i32 [ [[INDVAR_NEXT]], [[LAB0:%.*]] ], [ 0, [[ENTRY:%.*]] ]
-; IS__CGSCC_OPM-NEXT:    [[PC_ADDR_0:%.*]] = getelementptr i32, i32* [[PC]], i32 [[INDVAR]]
-; IS__CGSCC_OPM-NEXT:    [[TMP1_PN:%.*]] = load i32, i32* [[PC_ADDR_0]], align 4
-; IS__CGSCC_OPM-NEXT:    [[INDIRECT_GOTO_DEST_IN:%.*]] = getelementptr inbounds [2 x i8*], [2 x i8*]* @bar.l, i32 0, i32 [[TMP1_PN]]
-; IS__CGSCC_OPM-NEXT:    [[INDIRECT_GOTO_DEST:%.*]] = load i8*, i8** [[INDIRECT_GOTO_DEST_IN]], align 8
-; IS__CGSCC_OPM-NEXT:    indirectbr i8* [[INDIRECT_GOTO_DEST]], [label [[LAB0]], label %end]
-;
-; IS__CGSCC_NPM: Function Attrs: nofree norecurse nosync nounwind readnone
-; IS__CGSCC_NPM-LABEL: define {{[^@]+}}@bar
-; IS__CGSCC_NPM-SAME: () #[[ATTR1:[0-9]+]] {
-; IS__CGSCC_NPM-NEXT:  entry:
-; IS__CGSCC_NPM-NEXT:    br label [[INDIRECTGOTO:%.*]]
-; IS__CGSCC_NPM:       lab0:
-; IS__CGSCC_NPM-NEXT:    [[INDVAR_NEXT:%.*]] = add i32 [[INDVAR:%.*]], 1
-; IS__CGSCC_NPM-NEXT:    br label [[INDIRECTGOTO]]
-; IS__CGSCC_NPM:       end:
-; IS__CGSCC_NPM-NEXT:    ret void
-; IS__CGSCC_NPM:       indirectgoto:
-; IS__CGSCC_NPM-NEXT:    [[INDVAR]] = phi i32 [ [[INDVAR_NEXT]], [[LAB0:%.*]] ], [ 0, [[ENTRY:%.*]] ]
-; IS__CGSCC_NPM-NEXT:    indirectbr i8* undef, [label [[LAB0]], label %end]
+; IS__CGSCC____: Function Attrs: nounwind readonly
+; IS__CGSCC____-LABEL: define {{[^@]+}}@bar
+; IS__CGSCC____-SAME: (i32* nocapture [[PC:%.*]]) #[[ATTR1:[0-9]+]] {
+; IS__CGSCC____-NEXT:  entry:
+; IS__CGSCC____-NEXT:    br label [[INDIRECTGOTO:%.*]]
+; IS__CGSCC____:       lab0:
+; IS__CGSCC____-NEXT:    [[INDVAR_NEXT:%.*]] = add i32 [[INDVAR:%.*]], 1
+; IS__CGSCC____-NEXT:    br label [[INDIRECTGOTO]]
+; IS__CGSCC____:       end:
+; IS__CGSCC____-NEXT:    ret void
+; IS__CGSCC____:       indirectgoto:
+; IS__CGSCC____-NEXT:    [[INDVAR]] = phi i32 [ [[INDVAR_NEXT]], [[LAB0:%.*]] ], [ 0, [[ENTRY:%.*]] ]
+; IS__CGSCC____-NEXT:    [[PC_ADDR_0:%.*]] = getelementptr i32, i32* [[PC]], i32 [[INDVAR]]
+; IS__CGSCC____-NEXT:    [[TMP1_PN:%.*]] = load i32, i32* [[PC_ADDR_0]], align 4
+; IS__CGSCC____-NEXT:    [[INDIRECT_GOTO_DEST_IN:%.*]] = getelementptr inbounds [2 x i8*], [2 x i8*]* @bar.l, i32 0, i32 [[TMP1_PN]]
+; IS__CGSCC____-NEXT:    [[INDIRECT_GOTO_DEST:%.*]] = load i8*, i8** [[INDIRECT_GOTO_DEST_IN]], align 8
+; IS__CGSCC____-NEXT:    indirectbr i8* [[INDIRECT_GOTO_DEST]], [label [[LAB0]], label %end]
 ;
 entry:
   br label %indirectgoto
@@ -104,11 +90,7 @@
 ;.
 ; IS__TUNIT____: attributes #[[ATTR0]] = { nofree nosync nounwind readnone willreturn }
 ;.
-; IS__CGSCC_OPM: attributes #[[ATTR0]] = { nounwind readnone }
-; IS__CGSCC_OPM: attributes #[[ATTR1]] = { nounwind readonly }
-; IS__CGSCC_OPM: attributes #[[ATTR2]] = { nofree norecurse nosync nounwind readnone willreturn }
-;.
-; IS__CGSCC_NPM: attributes #[[ATTR0]] = { nounwind readnone }
-; IS__CGSCC_NPM: attributes #[[ATTR1]] = { nofree norecurse nosync nounwind readnone }
-; IS__CGSCC_NPM: attributes #[[ATTR2]] = { nofree norecurse nosync nounwind readnone willreturn }
+; IS__CGSCC____: attributes #[[ATTR0]] = { nounwind readnone }
+; IS__CGSCC____: attributes #[[ATTR1]] = { nounwind readonly }
+; IS__CGSCC____: attributes #[[ATTR2]] = { nofree norecurse nosync nounwind readnone willreturn }
 ;.
diff -ruN llvm-project/llvm/test/Transforms/Attributor/liveness.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Attributor/liveness.ll
--- llvm-project/llvm/test/Transforms/Attributor/liveness.ll	2023-05-24 11:35:49.552323162 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Attributor/liveness.ll	2022-02-01 09:13:46.451669313 -0500
@@ -2432,9 +2432,9 @@
 ; IS__CGSCC_OPM-NEXT:    [[INDIRECT_GOTO_DEST:%.*]] = load i8*, i8** [[INDIRECT_GOTO_DEST_IN]]
 ; IS__CGSCC_OPM-NEXT:    indirectbr i8* [[INDIRECT_GOTO_DEST]], [label [[LAB0]], label %end]
 ;
-; IS__CGSCC____: Function Attrs: nofree norecurse nosync nounwind readnone
+; IS__CGSCC____: Function Attrs: nounwind readonly
 ; IS__CGSCC____-LABEL: define {{[^@]+}}@dead_with_blockaddress_users
-; IS__CGSCC____-SAME: () #[[ATTR14:[0-9]+]] {
+; IS__CGSCC____-SAME: (i32* nocapture [[PC:%.*]]) #[[ATTR14:[0-9]+]] {
 ; IS__CGSCC____-NEXT:  entry:
 ; IS__CGSCC____-NEXT:    br label [[INDIRECTGOTO:%.*]]
 ; IS__CGSCC____:       lab0:
@@ -2444,7 +2444,11 @@
 ; IS__CGSCC____-NEXT:    ret void
 ; IS__CGSCC____:       indirectgoto:
 ; IS__CGSCC____-NEXT:    [[INDVAR]] = phi i32 [ [[INDVAR_NEXT]], [[LAB0:%.*]] ], [ 0, [[ENTRY:%.*]] ]
-; IS__CGSCC____-NEXT:    indirectbr i8* undef, [label [[LAB0]], label %end]
+; IS__CGSCC____-NEXT:    [[PC_ADDR_0:%.*]] = getelementptr i32, i32* [[PC]], i32 [[INDVAR]]
+; IS__CGSCC____-NEXT:    [[TMP1_PN:%.*]] = load i32, i32* [[PC_ADDR_0]], align 4
+; IS__CGSCC____-NEXT:    [[INDIRECT_GOTO_DEST_IN:%.*]] = getelementptr inbounds [2 x i8*], [2 x i8*]* @dead_with_blockaddress_users.l, i32 0, i32 [[TMP1_PN]]
+; IS__CGSCC____-NEXT:    [[INDIRECT_GOTO_DEST:%.*]] = load i8*, i8** [[INDIRECT_GOTO_DEST_IN]], align 8
+; IS__CGSCC____-NEXT:    indirectbr i8* [[INDIRECT_GOTO_DEST]], [label [[LAB0]], label %end]
 ;
 entry:
   br label %indirectgoto
@@ -2655,7 +2659,7 @@
 ; IS__CGSCC____: attributes #[[ATTR11]] = { nofree norecurse noreturn nosync nounwind readnone }
 ; IS__CGSCC____: attributes #[[ATTR12]] = { nofree norecurse noreturn nosync nounwind readnone willreturn }
 ; IS__CGSCC____: attributes #[[ATTR13]] = { nofree nosync nounwind willreturn }
-; IS__CGSCC____: attributes #[[ATTR14]] = { nofree norecurse nosync nounwind readnone }
+; IS__CGSCC____: attributes #[[ATTR14]] = { nounwind readonly }
 ; IS__CGSCC____: attributes #[[ATTR15]] = { nofree nosync nounwind readnone willreturn }
 ; IS__CGSCC____: attributes #[[ATTR16:[0-9]+]] = { argmemonly nofree nosync nounwind willreturn }
 ; IS__CGSCC____: attributes #[[ATTR17]] = { nounwind willreturn }
diff -ruN llvm-project/llvm/test/Transforms/Coroutines/coro-split-musttail4.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Coroutines/coro-split-musttail4.ll
--- llvm-project/llvm/test/Transforms/Coroutines/coro-split-musttail4.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Coroutines/coro-split-musttail4.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,65 @@
+; Tests that coro-split will convert a call before coro.suspend to a musttail call
+; while the user of the coro.suspend is a icmpinst.
+; RUN: opt < %s -passes='cgscc(coro-split),simplifycfg,early-cse' -S | FileCheck %s
+
+define void @fakeresume1(i8*)  {
+entry:
+  ret void;
+}
+
+define void @f() #0 {
+entry:
+  %id = call token @llvm.coro.id(i32 0, i8* null, i8* null, i8* null)
+  %alloc = call i8* @malloc(i64 16) #3
+  %vFrame = call noalias nonnull i8* @llvm.coro.begin(token %id, i8* %alloc)
+
+  %save = call token @llvm.coro.save(i8* null)
+
+  %init_suspend = call i8 @llvm.coro.suspend(token %save, i1 false)
+  switch i8 %init_suspend, label %coro.end [
+    i8 0, label %await.ready
+    i8 1, label %coro.end
+  ]
+await.ready:
+  %save2 = call token @llvm.coro.save(i8* null)
+
+  call fastcc void @fakeresume1(i8* align 8 null)
+  %suspend = call i8 @llvm.coro.suspend(token %save2, i1 true)
+  %switch = icmp ult i8 %suspend, 2
+  br i1 %switch, label %cleanup, label %coro.end
+
+cleanup:
+  %free.handle = call i8* @llvm.coro.free(token %id, i8* %vFrame)
+  %.not = icmp eq i8* %free.handle, null
+  br i1 %.not, label %coro.end, label %coro.free
+
+coro.free:
+  call void @delete(i8* nonnull %free.handle) #2
+  br label %coro.end
+
+coro.end:
+  call i1 @llvm.coro.end(i8* null, i1 false)
+  ret void
+}
+
+; CHECK-LABEL: @f.resume(
+; CHECK:          musttail call fastcc void @fakeresume1(
+; CHECK-NEXT:     ret void
+
+declare token @llvm.coro.id(i32, i8* readnone, i8* nocapture readonly, i8*) #1
+declare i1 @llvm.coro.alloc(token) #2
+declare i64 @llvm.coro.size.i64() #3
+declare i8* @llvm.coro.begin(token, i8* writeonly) #2
+declare token @llvm.coro.save(i8*) #2
+declare i8* @llvm.coro.frame() #3
+declare i8 @llvm.coro.suspend(token, i1) #2
+declare i8* @llvm.coro.free(token, i8* nocapture readonly) #1
+declare i1 @llvm.coro.end(i8*, i1) #2
+declare i8* @llvm.coro.subfn.addr(i8* nocapture readonly, i8) #1
+declare i8* @malloc(i64)
+declare void @delete(i8* nonnull) #2
+
+attributes #0 = { "coroutine.presplit"="1" }
+attributes #1 = { argmemonly nounwind readonly }
+attributes #2 = { nounwind }
+attributes #3 = { nounwind readnone }
diff -ruN llvm-project/llvm/test/Transforms/DeadStoreElimination/store-after-loop.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/DeadStoreElimination/store-after-loop.ll
--- llvm-project/llvm/test/Transforms/DeadStoreElimination/store-after-loop.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/DeadStoreElimination/store-after-loop.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,61 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt < %s -passes=dse -S | FileCheck %s
+
+target datalayout = "E-m:e-p:32:32-i64:32-f64:32:64-a:0:32-n32-S32"
+
+%struct.ilist = type { i32, %struct.ilist* }
+
+; There is no dead store in this test. Make sure no store is deleted by DSE.
+; Test case related to bug report PR52774.
+
+define %struct.ilist* @test() {
+; CHECK-LABEL: @test(
+; CHECK-NEXT:    br label [[LOOP:%.*]]
+; CHECK:       loop:
+; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ 0, [[TMP0:%.*]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
+; CHECK-NEXT:    [[LIST_NEXT:%.*]] = phi %struct.ilist* [ null, [[TMP0]] ], [ [[LIST_NEW_ILIST_PTR:%.*]], [[LOOP]] ]
+; CHECK-NEXT:    [[LIST_NEW_I8_PTR:%.*]] = tail call align 8 dereferenceable_or_null(8) i8* @malloc(i32 8)
+; CHECK-NEXT:    [[LIST_NEW_ILIST_PTR]] = bitcast i8* [[LIST_NEW_I8_PTR]] to %struct.ilist*
+; CHECK-NEXT:    [[GEP_NEW_VALUE:%.*]] = getelementptr inbounds [[STRUCT_ILIST:%.*]], %struct.ilist* [[LIST_NEW_ILIST_PTR]], i32 0, i32 0
+; CHECK-NEXT:    store i32 42, i32* [[GEP_NEW_VALUE]], align 8
+; CHECK-NEXT:    [[GEP_NEW_NEXT:%.*]] = getelementptr inbounds [[STRUCT_ILIST]], %struct.ilist* [[LIST_NEW_ILIST_PTR]], i32 0, i32 1
+; CHECK-NEXT:    store %struct.ilist* [[LIST_NEXT]], %struct.ilist** [[GEP_NEW_NEXT]], align 4
+; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i32 [[IV]], 1
+; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[IV_NEXT]], 10
+; CHECK-NEXT:    br i1 [[COND]], label [[EXIT:%.*]], label [[LOOP]]
+; CHECK:       exit:
+; CHECK-NEXT:    [[LIST_LAST_ILIST_PTR:%.*]] = bitcast i8* [[LIST_NEW_I8_PTR]] to %struct.ilist*
+; CHECK-NEXT:    [[GEP_LIST_LAST_NEXT:%.*]] = getelementptr inbounds [[STRUCT_ILIST]], %struct.ilist* [[LIST_LAST_ILIST_PTR]], i32 0, i32 1
+; CHECK-NEXT:    store %struct.ilist* null, %struct.ilist** [[GEP_LIST_LAST_NEXT]], align 4
+; CHECK-NEXT:    [[GEP_LIST_NEXT_NEXT:%.*]] = getelementptr inbounds [[STRUCT_ILIST]], %struct.ilist* [[LIST_NEXT]], i32 0, i32 1
+; CHECK-NEXT:    [[LOADED_PTR:%.*]] = load %struct.ilist*, %struct.ilist** [[GEP_LIST_NEXT_NEXT]], align 4
+; CHECK-NEXT:    ret %struct.ilist* [[LOADED_PTR]]
+;
+  br label %loop
+
+loop:
+  %iv = phi i32 [ 0, %0 ], [ %iv.next, %loop ]
+  %list.next = phi %struct.ilist* [ null, %0 ], [ %list.new.ilist.ptr, %loop ]
+  %list.new.i8.ptr = tail call align 8 dereferenceable_or_null(8) i8* @malloc(i32 8)
+  %list.new.ilist.ptr = bitcast i8* %list.new.i8.ptr to %struct.ilist*
+  %gep.new.value = getelementptr inbounds %struct.ilist, %struct.ilist* %list.new.ilist.ptr, i32 0, i32 0
+  store i32 42, i32* %gep.new.value, align 8
+  %gep.new.next = getelementptr inbounds %struct.ilist, %struct.ilist* %list.new.ilist.ptr, i32 0, i32 1
+  store %struct.ilist* %list.next, %struct.ilist** %gep.new.next, align 4
+  %iv.next = add nuw nsw i32 %iv, 1
+  %cond = icmp eq i32 %iv.next, 10
+  br i1 %cond, label %exit, label %loop
+
+exit:
+  %list.last.ilist.ptr = bitcast i8* %list.new.i8.ptr to %struct.ilist*
+  %gep.list.last.next = getelementptr inbounds %struct.ilist, %struct.ilist* %list.last.ilist.ptr, i32 0, i32 1
+  store %struct.ilist* null, %struct.ilist** %gep.list.last.next, align 4
+  %gep.list.next.next = getelementptr inbounds %struct.ilist, %struct.ilist* %list.next, i32 0, i32 1
+  %loaded_ptr = load %struct.ilist*, %struct.ilist** %gep.list.next.next, align 4
+  ret %struct.ilist* %loaded_ptr                                      ; use loaded pointer
+}
+
+; Function Attrs: inaccessiblememonly nounwind
+declare noalias noundef align 8 i8* @malloc(i32 noundef) local_unnamed_addr #0
+
+attributes #0 = { inaccessiblememonly nounwind}
diff -ruN llvm-project/llvm/test/Transforms/Inline/call-intrinsic-is-constant.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Inline/call-intrinsic-is-constant.ll
--- llvm-project/llvm/test/Transforms/Inline/call-intrinsic-is-constant.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/Inline/call-intrinsic-is-constant.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,39 @@
+; RUN: opt %s -passes=inline -inline-threshold=20 -S | FileCheck %s
+
+declare i1 @llvm.is.constant.i64(i64)
+declare void @foo()
+
+define void @callee(i64 %val) {
+  %cond = call i1 @llvm.is.constant.i64(i64 %val)
+  br i1 %cond, label %cond.true, label %cond.false
+
+cond.true:
+; Rack up costs with a couple of function calls so that this function
+; gets inlined only when @llvm.is.constant.i64 is folded.  In reality,
+; the "then" clause of __builtin_constant_p tends to have statements
+; that fold very well, so the cost of the "then" clause is not a huge
+; concern.
+  call void @foo()
+  call void @foo()
+  ret void
+
+cond.false:
+  ret void
+}
+
+define void @caller(i64 %val) {
+; CHECK-LABEL: @caller(
+; CHECK-NEXT:    [[COND_I:%.*]] = call i1 @llvm.is.constant.i64(i64 [[VAL:%.*]])
+; CHECK-NEXT:    br i1 [[COND_I]], label %[[COND_TRUE_I:.*]], label %[[COND_FALSE_I:.*]]
+; CHECK:       [[COND_TRUE_I]]:
+; CHECK-NEXT:    call void @foo()
+; CHECK-NEXT:    call void @foo()
+; CHECK-NEXT:    br label %[[CALLEE_EXIT:.*]]
+; CHECK:       [[COND_FALSE_I]]:
+; CHECK-NEXT:    br label %[[CALLEE_EXIT]]
+; CHECK:       [[CALLEE_EXIT]]:
+; CHECK-NEXT:    ret void
+;
+  call void @callee(i64 %val)
+  ret void
+}
diff -ruN llvm-project/llvm/test/Transforms/InstCombine/malloc-free.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/InstCombine/malloc-free.ll
--- llvm-project/llvm/test/Transforms/InstCombine/malloc-free.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/InstCombine/malloc-free.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,79 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt < %s -instcombine -S | FileCheck %s
+
+declare noalias i8* @calloc(i32, i32) nounwind
+declare noalias i8* @malloc(i32)
+declare noalias i8* @aligned_alloc(i32, i32)
+declare void @free(i8*)
+
+;; Test that nonnull-implying attributes on the parameter are adjusted when the
+;; call is moved, since they may no longer be valid and result in miscompiles if
+;; kept unchanged.
+define void @test_nonnull_free_move(i8* %foo) minsize {
+; CHECK-LABEL: @test_nonnull_free_move(
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i8* [[FOO:%.*]], null
+; CHECK-NEXT:    tail call void @free(i8* [[FOO]])
+; CHECK-NEXT:    br i1 [[TOBOOL]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
+; CHECK:       if.then:
+; CHECK-NEXT:    br label [[IF_END]]
+; CHECK:       if.end:
+; CHECK-NEXT:    ret void
+;
+entry:
+  %tobool = icmp eq i8* %foo, null
+  br i1 %tobool, label %if.end, label %if.then
+
+if.then:                                          ; preds = %entry
+  tail call void @free(i8* nonnull %foo)
+  br label %if.end
+
+if.end:                                           ; preds = %entry, %if.then
+  ret void
+}
+
+define void @test_dereferenceable_free_move(i8* %foo) minsize {
+; CHECK-LABEL: @test_dereferenceable_free_move(
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i8* [[FOO:%.*]], null
+; CHECK-NEXT:    tail call void @free(i8* dereferenceable_or_null(4) [[FOO]])
+; CHECK-NEXT:    br i1 [[TOBOOL]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
+; CHECK:       if.then:
+; CHECK-NEXT:    br label [[IF_END]]
+; CHECK:       if.end:
+; CHECK-NEXT:    ret void
+;
+entry:
+  %tobool = icmp eq i8* %foo, null
+  br i1 %tobool, label %if.end, label %if.then
+
+if.then:                                          ; preds = %entry
+  tail call void @free(i8* dereferenceable(4) %foo)
+  br label %if.end
+
+if.end:                                           ; preds = %entry, %if.then
+  ret void
+}
+
+define void @test_nonnull_dereferenceable_free_move(i8* %foo) minsize {
+; CHECK-LABEL: @test_nonnull_dereferenceable_free_move(
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    [[TOBOOL:%.*]] = icmp eq i8* [[FOO:%.*]], null
+; CHECK-NEXT:    tail call void @free(i8* dereferenceable_or_null(16) [[FOO]])
+; CHECK-NEXT:    br i1 [[TOBOOL]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
+; CHECK:       if.then:
+; CHECK-NEXT:    br label [[IF_END]]
+; CHECK:       if.end:
+; CHECK-NEXT:    ret void
+;
+entry:
+  %tobool = icmp eq i8* %foo, null
+  br i1 %tobool, label %if.end, label %if.then
+
+if.then:                                          ; preds = %entry
+  tail call void @free(i8* nonnull dereferenceable(16) %foo)
+  br label %if.end
+
+if.end:                                           ; preds = %entry, %if.then
+  ret void
+}
diff -ruN llvm-project/llvm/test/Transforms/MergeICmps/X86/addressspaces.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/MergeICmps/X86/addressspaces.ll
--- llvm-project/llvm/test/Transforms/MergeICmps/X86/addressspaces.ll	1969-12-31 19:00:00.000000000 -0500
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/MergeICmps/X86/addressspaces.ll	2022-02-01 09:13:46.451669313 -0500
@@ -0,0 +1,94 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
+; RUN: opt < %s -S -mergeicmps -verify-dom-info | FileCheck %s
+target triple = "x86_64"
+
+; First check that we try to from a memcmp.
+define void @form_memcmp([2 x i64]* dereferenceable(16) %a, [2 x i64]* dereferenceable(16) %b) {
+; CHECK-LABEL: @form_memcmp(
+; CHECK-NEXT:  bb0:
+; CHECK-NEXT:    [[PTR_A0:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[A:%.*]], i64 0, i64 0
+; CHECK-NEXT:    [[PTR_A1:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[A]], i64 0, i64 1
+; CHECK-NEXT:    [[PTR_B0:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[B:%.*]], i64 0, i64 0
+; CHECK-NEXT:    [[PTR_B1:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[B]], i64 0, i64 1
+; CHECK-NEXT:    br label %"bb1+bb2"
+; CHECK:       "bb1+bb2":
+; CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[A]], i64 0, i64 0
+; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [2 x i64], [2 x i64]* [[B]], i64 0, i64 0
+; CHECK-NEXT:    [[CSTR:%.*]] = bitcast i64* [[TMP0]] to i8*
+; CHECK-NEXT:    [[CSTR1:%.*]] = bitcast i64* [[TMP1]] to i8*
+; CHECK-NEXT:    [[MEMCMP:%.*]] = call i32 @memcmp(i8* [[CSTR]], i8* [[CSTR1]], i64 16)
+; CHECK-NEXT:    [[TMP2:%.*]] = icmp eq i32 [[MEMCMP]], 0
+; CHECK-NEXT:    br label [[BB3:%.*]]
+; CHECK:       bb3:
+; CHECK-NEXT:    ret void
+;
+bb0:
+  %ptr_a0 = getelementptr inbounds [2 x i64], [2 x i64]* %a, i64 0, i64 0
+  %ptr_a1 = getelementptr inbounds [2 x i64], [2 x i64]* %a, i64 0, i64 1
+  %ptr_b0 = getelementptr inbounds [2 x i64], [2 x i64]* %b, i64 0, i64 0
+  %ptr_b1 = getelementptr inbounds [2 x i64], [2 x i64]* %b, i64 0, i64 1
+  br label %bb1
+
+bb1:                                              ; preds = %bb0
+  %a0 = load i64, i64* %ptr_a0
+  %b0 = load i64, i64* %ptr_b0
+  %cond0 = icmp eq i64 %a0, %b0
+  br i1 %cond0, label %bb2, label %bb3
+
+bb2:                                              ; preds = %bb1
+  %a1 = load i64, i64* %ptr_a1
+  %b1 = load i64, i64* %ptr_b1
+  %cond1 = icmp eq i64 %a1, %b1
+  br label %bb3
+
+bb3:                                              ; preds = %bb2, %bb1
+  %necessary = phi i1 [ %cond1, %bb2 ], [ false, %bb1 ]
+  ret void
+}
+
+; We can't use memcmp between arbitrary addressesspaces
+define void @no_memcmp([2 x i64] addrspace(11)* dereferenceable(16) %a, [2 x i64] addrspace(11)* dereferenceable(16) %b) {
+; CHECK-LABEL: @no_memcmp(
+; CHECK-NEXT:  bb0:
+; CHECK-NEXT:    [[PTR_A0:%.*]] = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* [[A:%.*]], i64 0, i64 0
+; CHECK-NEXT:    [[PTR_A1:%.*]] = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* [[A]], i64 0, i64 1
+; CHECK-NEXT:    [[PTR_B0:%.*]] = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* [[B:%.*]], i64 0, i64 0
+; CHECK-NEXT:    [[PTR_B1:%.*]] = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* [[B]], i64 0, i64 1
+; CHECK-NEXT:    br label [[BB1:%.*]]
+; CHECK:       bb1:
+; CHECK-NEXT:    [[A0:%.*]] = load i64, i64 addrspace(11)* [[PTR_A0]], align 4
+; CHECK-NEXT:    [[B0:%.*]] = load i64, i64 addrspace(11)* [[PTR_B0]], align 4
+; CHECK-NEXT:    [[COND0:%.*]] = icmp eq i64 [[A0]], [[B0]]
+; CHECK-NEXT:    br i1 [[COND0]], label [[BB2:%.*]], label [[BB3:%.*]]
+; CHECK:       bb2:
+; CHECK-NEXT:    [[A1:%.*]] = load i64, i64 addrspace(11)* [[PTR_A1]], align 4
+; CHECK-NEXT:    [[B1:%.*]] = load i64, i64 addrspace(11)* [[PTR_B1]], align 4
+; CHECK-NEXT:    [[COND1:%.*]] = icmp eq i64 [[A1]], [[B1]]
+; CHECK-NEXT:    br label [[BB3]]
+; CHECK:       bb3:
+; CHECK-NEXT:    [[NECESSARY:%.*]] = phi i1 [ [[COND1]], [[BB2]] ], [ false, [[BB1]] ]
+; CHECK-NEXT:    ret void
+;
+bb0:
+  %ptr_a0 = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* %a, i64 0, i64 0
+  %ptr_a1 = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* %a, i64 0, i64 1
+  %ptr_b0 = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* %b, i64 0, i64 0
+  %ptr_b1 = getelementptr inbounds [2 x i64], [2 x i64] addrspace(11)* %b, i64 0, i64 1
+  br label %bb1
+
+bb1:                                              ; preds = %bb0
+  %a0 = load i64, i64 addrspace(11)* %ptr_a0
+  %b0 = load i64, i64 addrspace(11)* %ptr_b0
+  %cond0 = icmp eq i64 %a0, %b0
+  br i1 %cond0, label %bb2, label %bb3
+
+bb2:                                              ; preds = %bb1
+  %a1 = load i64, i64 addrspace(11)* %ptr_a1
+  %b1 = load i64, i64 addrspace(11)* %ptr_b1
+  %cond1 = icmp eq i64 %a1, %b1
+  br label %bb3
+
+bb3:                                              ; preds = %bb2, %bb1
+  %necessary = phi i1 [ %cond1, %bb2 ], [ false, %bb1 ]
+  ret void
+}
diff -ruN llvm-project/llvm/test/Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll
--- llvm-project/llvm/test/Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll	2023-05-24 11:35:49.808325925 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/RelLookupTableConverter/X86/relative_lookup_table.ll	2022-02-01 09:13:46.451669313 -0500
@@ -12,6 +12,9 @@
 @.str.5 = private unnamed_addr constant [5 x i8] c"str1\00", align 1
 @.str.6 = private unnamed_addr constant [5 x i8] c"str2\00", align 1
 @.str.7 = private unnamed_addr constant [12 x i8] c"singlevalue\00", align 1
+@.str.8 = private unnamed_addr constant [2 x i8] c"a\00", align 1
+@.str.9 = private unnamed_addr constant [2 x i8] c"b\00", align 1
+@.str.10 = private unnamed_addr constant [2 x i8] c"c\00", align 1
 
 @a1 = external global i32, align 4
 @b1 = external global i32, align 4
@@ -56,6 +59,16 @@
                                     i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0)
                                    ], align 16
 
+@table = internal constant [2 x i8*] [
+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0),
+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.9, i32 0, i32 0)
+], align 16
+
+@table2 = internal constant [2 x i8*] [
+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.8, i32 0, i32 0),
+  i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.9, i32 0, i32 0)
+], align 16
+
 ; Lookup table check for integer pointers that have external linkage
 ; CHECK: @switch.table.external_linkage = private unnamed_addr constant [3 x i32*] [i32* @a1, i32* @b1, i32* @c1], align
 
@@ -93,6 +106,20 @@
 ; CHECK-SAME: ], align 4
 ;
 
+; Relative lookup table for the loop hoist check test
+; CHECK: @reltable.loop_hoist = internal unnamed_addr constant [2 x i32]
+; CHECK-SAME: [
+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.8 to i64), i64 ptrtoint ([2 x i32]* @reltable.loop_hoist to i64)) to i32),
+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.9 to i64), i64 ptrtoint ([2 x i32]* @reltable.loop_hoist to i64)) to i32)
+; CHECK-SAME: ], align 4
+
+; Relative look up table for the test where gep is not immediately followed by a load check
+; CHECK: @reltable.gep_is_not_imm_followed_by_load = internal unnamed_addr constant [2 x i32]
+; CHECK-SAME: [
+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.8 to i64), i64 ptrtoint ([2 x i32]* @reltable.gep_is_not_imm_followed_by_load to i64)) to i32),
+; CHECK-SAME: i32 trunc (i64 sub (i64 ptrtoint ([2 x i8]* @.str.9 to i64), i64 ptrtoint ([2 x i32]* @reltable.gep_is_not_imm_followed_by_load to i64)) to i32)
+; CHECK-SAME: ], align 4
+
 ; Lookup table check for integer pointers that have external linkage
 define i32* @external_linkage(i32 %cond) {
 ; CHECK-LABEL: @external_linkage(
@@ -260,6 +287,59 @@
   ret i8* %cond1
 }
 
+; Check to ensure that call @llvm.load.relative is inserted before load, not before gep.
+; When a lookup table is accessed inside a loop, and a gep is hosted outside the loop via licm,
+; make sure that call @llvm.load.relative is inserted before load.
+define i8* @loop_hoist(i32 %x) {
+; CHECK-LABEL: @loop_hoist(i32 %x)
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    [[TMP0:%.*]] = icmp sgt i32 [[X:%.*]], 1
+; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0
+; CHECK-NEXT:    [[RELTABLE_SHIFT:%.*]] = shl i32 [[X:%.*]], 2
+; CHECK-NEXT:    br i1 [[TMP0]], label %if.done, label %if.false
+; CHECK:       if.false:
+; CHECK-NEXT:    [[RELTABLE_INTRINSIC:%.*]] = call i8* @llvm.load.relative.i32(i8* bitcast ([2 x i32]* @reltable.loop_hoist to i8*), i32 [[RELTABLE_SHIFT]])
+; CHECK-NEXT:    br label %if.done
+; CHECK:       if.done:
+; CHECK-NEXT:    [[TMP2:%.*]] = phi i8* [ [[TMP1]], %entry ], [ [[RELTABLE_INTRINSIC]], %if.false ]
+; CHECK-NEXT:    ret i8* [[TMP2]]
+;
+entry:
+  %0 = icmp sgt i32 %x, 1
+  %1 = getelementptr inbounds [2 x i8], [2 x i8]* @.str.10, i32 0, i32 0
+  %2 = getelementptr [2 x i8*], [2 x i8*]* @table, i32 0, i32 %x
+  br i1 %0, label %if.done, label %if.false
+
+if.false:
+  %3 = load i8*, i8** %2
+  br label %if.done
+
+if.done:
+  %4 = phi i8* [ %1, %entry ], [ %3, %if.false ]
+  ret i8* %4
+}
+
+; Another check to ensure that call @llvm.load.relative is inserted before load but not before gep.
+; When a lookup table is accessed, and gep is not immediately followed by a load (like if there is a function call
+; or an exception in between), make sure that call @llvm.load.relative is inserted before load.
+; CHECK-LABEL: @may_not_return()
+declare void @may_not_return()
+
+define i8* @gep_is_not_imm_followed_by_load(i32 %x) {
+; CHECK-LABEL: @gep_is_not_imm_followed_by_load(i32 %x)
+; CHECK:       entry:
+; CHECK-NEXT:    [[RELTABLE_SHIFT:%.*]] = shl i32 [[X:%.*]], 2
+; CHECK-NEXT:    call void @may_not_return()
+; CHECK-NEXT:    [[RELTABLE_INTRINSIC:%.*]] = call i8* @llvm.load.relative.i32(i8* bitcast ([2 x i32]* @reltable.gep_is_not_imm_followed_by_load to i8*), i32 [[RELTABLE_SHIFT]])
+; CHECK-NEXT:    ret i8* [[RELTABLE_INTRINSIC]]
+;
+entry:
+  %0 = getelementptr [2 x i8*], [2 x i8*]* @table2, i32 0, i32 %x
+  call void @may_not_return()
+  %1 = load i8*, i8** %0
+  ret i8* %1
+}
+
 !llvm.module.flags = !{!0, !1}
 !0 = !{i32 7, !"PIC Level", i32 2}
 !1 = !{i32 1, !"Code Model", i32 1}
diff -ruN llvm-project/llvm/test/Transforms/SLPVectorizer/X86/extract_in_tree_user.ll /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/SLPVectorizer/X86/extract_in_tree_user.ll
--- llvm-project/llvm/test/Transforms/SLPVectorizer/X86/extract_in_tree_user.ll	2023-05-24 11:35:49.828326141 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/test/Transforms/SLPVectorizer/X86/extract_in_tree_user.ll	2022-02-01 09:13:46.451669313 -0500
@@ -32,7 +32,6 @@
   ret i32 undef
 }
 
-
 declare float @llvm.powi.f32.i32(float, i32)
 define void @fn2(i32* %a, i32* %b, float* %c) {
 ; CHECK-LABEL: @fn2(
@@ -99,3 +98,36 @@
   ret void
 
 }
+
+define void @externally_used_ptrs() {
+; CHECK-LABEL: @externally_used_ptrs(
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    [[TMP0:%.*]] = load i64*, i64** @a, align 8
+; CHECK-NEXT:    [[TMP1:%.*]] = insertelement <2 x i64*> poison, i64* [[TMP0]], i32 0
+; CHECK-NEXT:    [[TMP2:%.*]] = insertelement <2 x i64*> [[TMP1]], i64* [[TMP0]], i32 1
+; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr i64, <2 x i64*> [[TMP2]], <2 x i64> <i64 56, i64 11>
+; CHECK-NEXT:    [[TMP4:%.*]] = ptrtoint <2 x i64*> [[TMP3]] to <2 x i64>
+; CHECK-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds i64, i64* [[TMP0]], i64 12
+; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x i64*> [[TMP3]], i32 1
+; CHECK-NEXT:    [[TMP6:%.*]] = bitcast i64* [[TMP5]] to <2 x i64>*
+; CHECK-NEXT:    [[TMP7:%.*]] = load <2 x i64>, <2 x i64>* [[TMP6]], align 8
+; CHECK-NEXT:    [[TMP9:%.*]] = add <2 x i64> [[TMP4]], [[TMP7]]
+; CHECK-NEXT:    [[TMP10:%.*]] = bitcast i64* [[TMP5]] to <2 x i64>*
+; CHECK-NEXT:    store <2 x i64> [[TMP9]], <2 x i64>* [[TMP10]], align 8
+; CHECK-NEXT:    ret void
+;
+entry:
+  %0 = load i64*, i64** @a, align 8
+  %add.ptr = getelementptr inbounds i64, i64* %0, i64 11
+  %1 = ptrtoint i64* %add.ptr to i64
+  %add.ptr1 = getelementptr inbounds i64, i64* %0, i64 56
+  %2 = ptrtoint i64* %add.ptr1 to i64
+  %arrayidx2 = getelementptr inbounds i64, i64* %0, i64 12
+  %3 = load i64, i64* %arrayidx2, align 8
+  %4 = load i64, i64* %add.ptr, align 8
+  %5 = add i64 %1, %3
+  %6 = add i64 %2, %4
+  store i64 %6, i64* %add.ptr, align 8
+  store i64 %5, i64* %arrayidx2, align 8
+  ret void
+}
diff -ruN llvm-project/llvm/unittests/Analysis/LazyCallGraphTest.cpp /home/dtrilla/git/novia/llvm-project/llvm/unittests/Analysis/LazyCallGraphTest.cpp
--- llvm-project/llvm/unittests/Analysis/LazyCallGraphTest.cpp	2023-05-24 11:35:50.176329897 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/unittests/Analysis/LazyCallGraphTest.cpp	2022-02-01 09:13:46.451669313 -0500
@@ -1978,7 +1978,8 @@
   LazyCallGraph::Node &G = *CG.lookup(lookupFunction(*M, "g"));
   EXPECT_EQ(&FRC, CG.lookupRefSCC(F));
   EXPECT_EQ(&GRC, CG.lookupRefSCC(G));
-  EXPECT_TRUE(GRC.isParentOf(FRC));
+  EXPECT_FALSE(GRC.isParentOf(FRC));
+  EXPECT_FALSE(FRC.isParentOf(GRC));
 }
 
 // Test that a blockaddress that refers to itself creates no new RefSCC
diff -ruN llvm-project/llvm/unittests/IR/DebugInfoTest.cpp /home/dtrilla/git/novia/llvm-project/llvm/unittests/IR/DebugInfoTest.cpp
--- llvm-project/llvm/unittests/IR/DebugInfoTest.cpp	2023-05-24 11:35:50.192330070 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/unittests/IR/DebugInfoTest.cpp	2022-02-01 09:13:46.451669313 -0500
@@ -7,8 +7,9 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/IR/DebugInfo.h"
-#include "llvm/IR/DIBuilder.h"
+#include "llvm/ADT/APSInt.h"
 #include "llvm/AsmParser/Parser.h"
+#include "llvm/IR/DIBuilder.h"
 #include "llvm/IR/DebugInfoMetadata.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/LLVMContext.h"
@@ -244,4 +245,21 @@
   EXPECT_TRUE(isa_and_nonnull<DIDerivedType>(SetType));
 }
 
+TEST(DIBuilder, DIEnumerator) {
+  LLVMContext Ctx;
+  std::unique_ptr<Module> M(new Module("MyModule", Ctx));
+  DIBuilder DIB(*M);
+  APSInt I1(APInt(32, 1));
+  APSInt I2(APInt(33, 1));
+
+  auto *E = DIEnumerator::get(Ctx, I1, I1.isSigned(), "name");
+  EXPECT_TRUE(E);
+
+  auto *E1 = DIEnumerator::getIfExists(Ctx, I1, I1.isSigned(), "name");
+  EXPECT_TRUE(E1);
+
+  auto *E2 = DIEnumerator::getIfExists(Ctx, I2, I1.isSigned(), "name");
+  EXPECT_FALSE(E2);
+}
+
 } // end namespace
diff -ruN llvm-project/llvm/utils/gn/secondary/llvm/version.gni /home/dtrilla/git/novia/llvm-project/llvm/utils/gn/secondary/llvm/version.gni
--- llvm-project/llvm/utils/gn/secondary/llvm/version.gni	2023-05-24 11:35:50.288331106 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/utils/gn/secondary/llvm/version.gni	2022-02-01 09:13:46.451669313 -0500
@@ -1,4 +1,4 @@
 llvm_version_major = 13
 llvm_version_minor = 0
-llvm_version_patch = 0
+llvm_version_patch = 1
 llvm_version = "$llvm_version_major.$llvm_version_minor.$llvm_version_patch"
Binary files llvm-project/llvm/utils/lit/lit/formats/__pycache__/base.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/formats/__pycache__/base.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/formats/__pycache__/googletest.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/formats/__pycache__/googletest.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/formats/__pycache__/__init__.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/formats/__pycache__/__init__.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/formats/__pycache__/shtest.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/formats/__pycache__/shtest.cpython-36.pyc differ
diff -ruN llvm-project/llvm/utils/lit/lit/__init__.py /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__init__.py
--- llvm-project/llvm/utils/lit/lit/__init__.py	2023-05-24 11:35:50.288331106 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__init__.py	2022-02-01 09:13:46.451669313 -0500
@@ -2,7 +2,7 @@
 
 __author__ = 'Daniel Dunbar'
 __email__ = 'daniel@minormatter.com'
-__versioninfo__ = (13, 0, 0)
+__versioninfo__ = (13, 0, 1)
 __version__ = '.'.join(str(v) for v in __versioninfo__) + 'dev'
 
 __all__ = []
Binary files llvm-project/llvm/utils/lit/lit/llvm/__pycache__/config.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/llvm/__pycache__/config.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/llvm/__pycache__/__init__.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/llvm/__pycache__/__init__.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/llvm/__pycache__/subst.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/llvm/__pycache__/subst.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/BooleanExpression.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/BooleanExpression.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/cl_arguments.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/cl_arguments.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/discovery.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/discovery.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/display.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/display.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/__init__.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/__init__.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/LitConfig.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/LitConfig.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/main.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/main.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/reports.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/reports.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/run.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/run.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/ShCommands.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/ShCommands.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/ShUtil.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/ShUtil.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/Test.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/Test.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/TestingConfig.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/TestingConfig.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/TestRunner.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/TestRunner.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/TestTimes.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/TestTimes.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/util.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/util.cpython-36.pyc differ
Binary files llvm-project/llvm/utils/lit/lit/__pycache__/worker.cpython-36.pyc and /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/__pycache__/worker.cpython-36.pyc differ
diff -ruN llvm-project/llvm/utils/lit/lit/TestingConfig.py /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/TestingConfig.py
--- llvm-project/llvm/utils/lit/lit/TestingConfig.py	2023-05-24 11:35:50.288331106 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/utils/lit/lit/TestingConfig.py	2022-02-01 09:13:46.451669313 -0500
@@ -28,7 +28,7 @@
                      'TMPDIR', 'TMP', 'TEMP', 'TEMPDIR', 'AVRLIT_BOARD',
                      'AVRLIT_PORT', 'FILECHECK_OPTS', 'VCINSTALLDIR',
                      'VCToolsinstallDir', 'VSINSTALLDIR', 'WindowsSdkDir',
-                     'WindowsSDKLibVersion']
+                     'WindowsSDKLibVersion', 'SOURCE_DATE_EPOCH']
 
         if sys.platform == 'win32':
             pass_vars.append('INCLUDE')
diff -ruN llvm-project/llvm/utils/release/build_llvm_package.bat /home/dtrilla/git/novia/llvm-project/llvm/utils/release/build_llvm_package.bat
--- llvm-project/llvm/utils/release/build_llvm_package.bat	2023-05-24 11:35:50.300331237 -0400
+++ /home/dtrilla/git/novia/llvm-project/llvm/utils/release/build_llvm_package.bat	2022-02-01 09:13:46.451669313 -0500
@@ -27,8 +27,8 @@
 for /f "usebackq" %%i in (`PowerShell ^(Get-Date^).ToString^('yyyyMMdd'^)`) do set datestamp=%%i
 
 set revision=%1
-set package_version=13.0.0-%revision:~0,8%
-set clang_format_vs_version=13.0.0.%datestamp%
+set package_version=13.0.1-%revision:~0,8%
+set clang_format_vs_version=13.0.1.%datestamp%
 set build_dir=llvm_package_%revision:~0,8%
 
 echo Revision: %revision%
