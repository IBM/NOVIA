diff --git a/llvm/include/llvm/CodeGen/ISDOpcodes.h b/llvm/include/llvm/CodeGen/ISDOpcodes.h
index 6803f4d76cf0..bf2453483594 100644
--- a/llvm/include/llvm/CodeGen/ISDOpcodes.h
+++ b/llvm/include/llvm/CodeGen/ISDOpcodes.h
@@ -259,6 +259,11 @@ enum NodeType {
   /// like ADDC/SUBC, which indicate the carry result is always false.
   CARRY_FALSE,
 
+  // NFU
+  SET_LOAD_NFU,
+  EXEC_NFU,
+  POP_NFU,
+
   /// Carry-setting nodes for multiple precision addition and subtraction.
   /// These nodes take two operands of the same value type, and produce two
   /// results.  The first result is the normal add or sub result, the second
diff --git a/llvm/include/llvm/IR/Intrinsics.td b/llvm/include/llvm/IR/Intrinsics.td
index 28fcc13266b1..82264c89c7bc 100644
--- a/llvm/include/llvm/IR/Intrinsics.td
+++ b/llvm/include/llvm/IR/Intrinsics.td
@@ -1761,6 +1761,19 @@ def int_experimental_vector_splice : DefaultAttrsIntrinsic<[llvm_anyvector_ty],
                                                             llvm_i32_ty],
                                                            [IntrNoMem, ImmArg<ArgIndex<2>>]>;
 
+//===------------------  NOVIA  --------------------------------------------===//
+def int_set_load_nfu : DefaultAttrsIntrinsic<[],
+                             [llvm_i32_ty,llvm_i32_ty,llvm_i32_ty,llvm_i32_ty],
+                             [IntrNoReturn, IntrNoMem, IntrHasSideEffects,ImmArg<ArgIndex<0>>, 
+                              ImmArg<ArgIndex<1>>, ImmArg<ArgIndex<2>>,ImmArg<ArgIndex<3>>]>;
+def int_exec_nfu : DefaultAttrsIntrinsic<[],[llvm_i32_ty,llvm_i32_ty],
+                             [IntrNoReturn,IntrHasSideEffects,ImmArg<ArgIndex<0>>,
+                              ImmArg<ArgIndex<1>>]>;
+def int_pop_nfu : DefaultAttrsIntrinsic<[llvm_any_ty],
+                             [llvm_i32_ty,llvm_i32_ty],
+                             [IntrNoMem, IntrHasSideEffects,ImmArg<ArgIndex<0>>,
+                              ImmArg<ArgIndex<1>>]>;
+
 //===----------------------------------------------------------------------===//
 
 //===----------------------------------------------------------------------===//
diff --git a/llvm/include/llvm/Target/TargetSelectionDAG.td b/llvm/include/llvm/Target/TargetSelectionDAG.td
index 44ec2250a9c5..34aab843651e 100644
--- a/llvm/include/llvm/Target/TargetSelectionDAG.td
+++ b/llvm/include/llvm/Target/TargetSelectionDAG.td
@@ -109,6 +109,9 @@ def SDTOther  : SDTypeProfile<1, 0, [SDTCisVT<0, OtherVT>]>; // for 'vt'.
 def SDTUNDEF  : SDTypeProfile<1, 0, []>;                     // for 'undef'.
 def SDTUnaryOp  : SDTypeProfile<1, 1, []>;                   // for bitconvert.
 
+def NOVIAOp1 : SDTypeProfile<0, 2, [SDTCisInt<0>, SDTCisInt<1> ]>;
+def NOVIAOp2 : SDTypeProfile<1, 2, [SDTCisInt<0>, SDTCisInt<1>, SDTCisInt<2> ]>;
+
 def SDTIntBinOp : SDTypeProfile<1, 2, [     // add, and, or, xor, udiv, etc.
   SDTCisSameAs<0, 1>, SDTCisSameAs<0, 2>, SDTCisInt<0>
 ]>;
@@ -453,6 +456,8 @@ def vecreduce_smin  : SDNode<"ISD::VECREDUCE_SMIN", SDTVecReduce>;
 def vecreduce_umin  : SDNode<"ISD::VECREDUCE_UMIN", SDTVecReduce>;
 def vecreduce_fadd  : SDNode<"ISD::VECREDUCE_FADD", SDTFPVecReduce>;
 
+def exec_nfu   : SDNode<"ISD::EXEC_NFU"   , NOVIAOp1>;
+def pop_nfu    : SDNode<"ISD::POP_NFU"    , NOVIAOp2>;
 def fadd       : SDNode<"ISD::FADD"       , SDTFPBinOp, [SDNPCommutative]>;
 def fsub       : SDNode<"ISD::FSUB"       , SDTFPBinOp>;
 def fmul       : SDNode<"ISD::FMUL"       , SDTFPBinOp, [SDNPCommutative]>;
diff --git a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
index dc245f0d7b16..26f2d271798b 100644
--- a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
@@ -266,7 +266,7 @@ namespace {
 
       // Skip handle nodes as they can't usefully be combined and confuse the
       // zero-use deletion strategy.
-      if (N->getOpcode() == ISD::HANDLENODE)
+      if (N->getOpcode() == ISD::HANDLENODE) 
         return;
 
       ConsiderForPruning(N);
diff --git a/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp b/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
index d92b23f56e4d..271085c6cf7c 100644
--- a/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
@@ -1109,6 +1109,11 @@ void SelectionDAGLegalize::LegalizeOp(SDNode *Node) {
     // They'll be converted to Copy(To/From)Reg.
     Action = TargetLowering::Legal;
     break;
+  case ISD::EXEC_NFU:
+  case ISD::POP_NFU:
+  case ISD::SET_LOAD_NFU:
+    Action = TargetLowering::Legal;
+    break;
   case ISD::UBSANTRAP:
     Action = TLI.getOperationAction(Node->getOpcode(), Node->getValueType(0));
     if (Action == TargetLowering::Expand) {
diff --git a/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp b/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
index bd2ebfd0bd3b..a6fc29fd9c5e 100644
--- a/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp
@@ -5808,6 +5808,24 @@ void SelectionDAGBuilder::visitIntrinsicCall(const CallInst &I,
              DAG.getVScale(getCurSDLoc(), VT, APInt(VT.getSizeInBits(), 1)));
     return;
   }
+  /*case Intrinsic::exec_nfu:{
+    //EVT VT = TLI.getValueType(DAG.getDataLayout(), I.getType());
+    //SDValue Imm1 = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(0))->getSExtValue(), sdl, MVT::i32);
+    //SDValue Imm2 = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(1))->getSExtValue(), sdl, MVT::i32);
+    //setValue(&I,Res);
+    SDVTList nodeTys = DAG.getVTList(MVT::Other);
+    SDValue Ops[2];
+    //Ops[0] = getRoot();
+    //Ops[1] = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(0))->getSExtValue(),sdl,MVT::i8);
+    //Ops[2] = DAG.getTargetConstant(cast<ConstantInt>(I.getOperand(1))->getSExtValue(),sdl,MVT::i8);
+    Ops[0] = getValue(I.getOperand(0));
+    Ops[1] = getValue(I.getOperand(1));
+    Res = DAG.getNode(ISD::EXEC_NFU,sdl,nodeTys,Ops);
+    SDValue TokenFactor = DAG.getNode(ISD::TokenFactor, sdl, MVT::Other,{Res});
+    setValue(&I,Res);
+    DAG.setRoot(TokenFactor);
+    return;
+    }*/
   case Intrinsic::vastart:  visitVAStart(I); return;
   case Intrinsic::vaend:    visitVAEnd(I); return;
   case Intrinsic::vacopy:   visitVACopy(I); return;
diff --git a/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp b/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp
index 40083c614a6c..d335a233396d 100644
--- a/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp
@@ -414,6 +414,8 @@ std::string SDNode::getOperationName(const SelectionDAG *G) const {
     return "call_setup";
   case ISD::PREALLOCATED_ARG:
     return "call_alloc";
+  case ISD::EXEC_NFU:                   return "exec_nfu";
+  case ISD::POP_NFU:                    return "pop_nfu";
 
   // Floating point environment manipulation
   case ISD::FLT_ROUNDS_:                return "flt_rounds";
diff --git a/llvm/lib/CodeGen/TargetLoweringBase.cpp b/llvm/lib/CodeGen/TargetLoweringBase.cpp
index 3c5dd29036db..51a6796627ab 100644
--- a/llvm/lib/CodeGen/TargetLoweringBase.cpp
+++ b/llvm/lib/CodeGen/TargetLoweringBase.cpp
@@ -755,6 +755,9 @@ void TargetLoweringBase::initActions() {
       setIndexedMaskedStoreAction(IM, VT, Expand);
     }
 
+    setOperationAction(ISD::EXEC_NFU,VT,Legal);
+    setOperationAction(ISD::SET_LOAD_NFU,VT,Legal);
+    setOperationAction(ISD::POP_NFU,VT,Legal);
     // Most backends expect to see the node which just returns the value loaded.
     setOperationAction(ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS, VT, Expand);
 
diff --git a/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp b/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
index 9866567ac1ee..bdec95821c2c 100644
--- a/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
+++ b/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp
@@ -451,6 +451,12 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
   MVT VT = Node->getSimpleValueType(0);
 
   switch (Opcode) {
+  case ISD::EXEC_NFU: {
+    SDValue Op1 = Node->getOperand(0);
+    SDValue Op2 = Node->getOperand(1);
+    ReplaceNode(Node, CurDAG->getMachineNode(RISCV::EXEC_NFU,DL,MVT::Other,{Op1,Op2}));
+    return;
+  }
   case ISD::Constant: {
     auto *ConstNode = cast<ConstantSDNode>(Node);
     if (VT == XLenVT && ConstNode->isNullValue()) {
@@ -629,6 +635,26 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
       // By default we do not custom select any intrinsic.
     default:
       break;
+    case Intrinsic::exec_nfu: {
+       /*         
+      SDValue Op1 = Node->getOperand(1);
+      SDValue Op2 = Node->getOperand(2);
+      ReplaceNode(Node,CurDAG->getMachineNode(ISD::EXEC_NFU,DL,MVT::i32,Op1,Op2));
+      return;*/
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      assert(C1 && C2 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::EXEC_NFU,DL,MVT::Other,{Imm1Node,Imm2Node}));
+    }
+      
     case Intrinsic::riscv_vmsgeu:
     case Intrinsic::riscv_vmsge: {
       SDValue Src1 = Node->getOperand(1);
@@ -837,7 +863,22 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
       // By default we do not custom select any intrinsic.
     default:
       break;
-
+    case Intrinsic::pop_nfu: {
+      EVT RetTy = Node->getValueType(0);
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      assert(C1 && C2 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::POP_NFU,DL,{RetTy,MVT::Other},{Imm1Node,Imm2Node,Node->getOperand(0)}));
+      return;
+    }
     case Intrinsic::riscv_vsetvli:
     case Intrinsic::riscv_vsetvlimax: {
       if (!Subtarget->hasStdExtV())
@@ -1093,6 +1134,50 @@ void RISCVDAGToDAGISel::Select(SDNode *Node) {
   case ISD::INTRINSIC_VOID: {
     unsigned IntNo = cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();
     switch (IntNo) {
+    case Intrinsic::exec_nfu: {
+       /*         
+      SDValue Op1 = Node->getOperand(1);
+      SDValue Op2 = Node->getOperand(2);
+      ReplaceNode(Node,CurDAG->getMachineNode(ISD::EXEC_NFU,DL,MVT::i32,Op1,Op2));
+      return;*/
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      assert(C1 && C2 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::EXEC_NFU,DL,MVT::Other,{Imm1Node,Imm2Node,Node->getOperand(0)}));
+      return;
+    }
+    case Intrinsic::set_load_nfu: {
+      ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Node->getOperand(2));
+      ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Node->getOperand(3));
+      ConstantSDNode *C3 = dyn_cast<ConstantSDNode>(Node->getOperand(4));
+      ConstantSDNode *C4 = dyn_cast<ConstantSDNode>(Node->getOperand(5));
+      assert(C1 && C2 && C3 && C4 && "Expected constant operands");
+      assert(C1->getSExtValue() <= 0x1F && "C1 Operand exceeds 5 bits");
+      assert(C2->getSExtValue() <= 0x1F && "C2 Operand exceeds 5 bits");
+      assert(C3->getSExtValue() <= 0x1F && "C3 Operand exceeds 5 bits");
+      assert(C4->getSExtValue() <= 0x1F && "C4 Operand exceeds 5 bits");
+
+      int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+      int64_t Imm2 = C2->getSExtValue() & 0x1F;
+      int64_t Imm3 = C3->getSExtValue() & 0x1F;
+      int64_t Imm4 = C4->getSExtValue() & 0x1F;
+
+      SDValue Imm1Node = CurDAG->getTargetConstant(Imm1, DL, MVT::i32);
+      SDValue Imm2Node = CurDAG->getTargetConstant(Imm2, DL, MVT::i32);
+      SDValue Imm3Node = CurDAG->getTargetConstant(Imm3, DL, MVT::i32);
+      SDValue Imm4Node = CurDAG->getTargetConstant(Imm4, DL, MVT::i32);
+      ReplaceNode(Node, CurDAG->getMachineNode(RISCV::SET_LOAD_NFU,DL,MVT::Other,{Imm1Node,
+            Imm2Node,Imm3Node,Imm4Node,Node->getOperand(0)}));
+      return;
+    }
     case Intrinsic::riscv_vsseg2:
     case Intrinsic::riscv_vsseg3:
     case Intrinsic::riscv_vsseg4:
diff --git a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
index 294532011650..aa99df35d447 100644
--- a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
+++ b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
@@ -167,6 +167,10 @@ RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
     setLoadExtAction(N, XLenVT, MVT::i1, Promote);
 
   // TODO: add all necessary setOperationAction calls.
+  setOperationAction(ISD::EXEC_NFU,MVT::i32,Custom);
+  setOperationAction(ISD::POP_NFU,MVT::Other,Custom);
+  setOperationAction(ISD::SET_LOAD_NFU,MVT::i32,Custom);
+
   setOperationAction(ISD::DYNAMIC_STACKALLOC, XLenVT, Expand);
 
   setOperationAction(ISD::BR_JT, MVT::Other, Expand);
@@ -3560,6 +3564,25 @@ SDValue RISCVTargetLowering::LowerINTRINSIC_WO_CHAIN(SDValue Op,
   switch (IntNo) {
   default:
     break; // Don't custom lower most intrinsics.
+  case Intrinsic::exec_nfu: {
+    /*SDValue Src1 = Op.getOperand(1);
+    SDValue Src2 = Op.getOperand(2);
+    SDLoc DL(Op);
+    SDValue Imm1 = DAG.getTargetConstant(cast<ConstantSDNode>(Src1)->getSExtValue(), DL, MVT::i32);
+    SDValue Imm2 = DAG.getTargetConstant(cast<ConstantSDNode>(Src2)->getSExtValue(), DL, MVT::i32);
+    return DAG.getNode(RISCV::EXEC_NFU,DL,XLenVT,Imm1,Imm2);*/
+    ConstantSDNode *C1 = dyn_cast<ConstantSDNode>(Op.getOperand(1));
+    ConstantSDNode *C2 = dyn_cast<ConstantSDNode>(Op.getOperand(2));
+    assert(C1 && C2 && "Expected constant operands");
+    assert(C1->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+    assert(C2->getSExtValue() <= 0x1F && "Operand exceeds 5 bits");
+
+    int64_t Imm1 = C1->getSExtValue() & 0x1F; // Mask the lower 5 bits
+    int64_t Imm2 = C2->getSExtValue() & 0x1F;
+    SDValue Imm1Node = DAG.getTargetConstant(Imm1, DL, MVT::i32);
+    SDValue Imm2Node = DAG.getTargetConstant(Imm2, DL, MVT::i32);
+    return DAG.getNode(ISD::EXEC_NFU,DL,MVT::Other,Imm1Node,Imm2Node);
+  }
   case Intrinsic::thread_pointer: {
     EVT PtrVT = getPointerTy(DAG.getDataLayout());
     return DAG.getRegister(RISCV::X4, PtrVT);
@@ -3710,6 +3733,15 @@ SDValue RISCVTargetLowering::LowerINTRINSIC_WO_CHAIN(SDValue Op,
 
 SDValue RISCVTargetLowering::LowerINTRINSIC_W_CHAIN(SDValue Op,
                                                     SelectionDAG &DAG) const {
+  unsigned IntNo = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
+  if(IntNo == Intrinsic::pop_nfu){
+    EVT RetTy = Op.getValueType();
+    SDValue Chain = Op.getOperand(0);
+    SDValue Op1 = Op.getOperand(2);
+    SDValue Op2 = Op.getOperand(3);
+    SDLoc DL(Op);
+    return DAG.getNode(ISD::POP_NFU, DL, RetTy, Chain, Op1, Op2);
+  }
   return lowerVectorIntrinsicSplats(Op, DAG, Subtarget);
 }
 
diff --git a/llvm/lib/Target/RISCV/RISCVInstrFormats.td b/llvm/lib/Target/RISCV/RISCVInstrFormats.td
index 8e9d245f13eb..e17009f9151f 100644
--- a/llvm/lib/Target/RISCV/RISCVInstrFormats.td
+++ b/llvm/lib/Target/RISCV/RISCVInstrFormats.td
@@ -48,6 +48,7 @@ def InstFormatCA     : InstFormat<14>;
 def InstFormatCB     : InstFormat<15>;
 def InstFormatCJ     : InstFormat<16>;
 def InstFormatOther  : InstFormat<17>;
+def InstFormatNFU    : InstFormat<18>;
 
 class RISCVVConstraint<bits<3> val> {
   bits<3> Value = val;
@@ -132,6 +133,7 @@ def OPC_BRANCH    : RISCVOpcode<0b1100011>;
 def OPC_JALR      : RISCVOpcode<0b1100111>;
 def OPC_JAL       : RISCVOpcode<0b1101111>;
 def OPC_SYSTEM    : RISCVOpcode<0b1110011>;
+def OPC_NFU       : RISCVOpcode<0b1011011>;
 
 class RVInst<dag outs, dag ins, string opcodestr, string argstr,
              list<dag> pattern, InstFormat format>
@@ -217,6 +219,33 @@ class PseudoStore<string opcodestr, RegisterClass rsty = GPR>
   let isAsmParserOnly = 1;
 }
 
+class NFUInstA<bits<3> funct, RISCVOpcode opcode, dag outs, dag ins, string opcodestr, string argstr >
+: RVInst<outs,ins,opcodestr,argstr,[],InstFormatNFU>{
+  bits<5> mask1;
+  bits<5> mask2;
+  bits<5> mask3;
+  bits<5> nfu;
+
+  let Inst{31-30} = 0;
+  let Inst{29-25} = mask3;
+  let Inst{24-20} = mask2;
+  let Inst{19-15} = mask1;
+  let Inst{14-10} = nfu;
+  let Inst{9-7} = funct;
+  let Opcode = opcode.Value;
+}
+
+class NFUInstB<bits<3> funct, RISCVOpcode opcode, dag outs, dag ins, string opcodestr, string argstr >
+      : RVInst<outs,ins, opcodestr, argstr, [], InstFormatNFU> {
+  bits<5> rd;
+  bits<5> nfu;
+
+  let Inst{31-20} = 0;
+  let Inst{19-15} = rd;
+  let Inst{14-10} = nfu;
+  let Inst{9-7} = funct;
+  let Opcode = opcode.Value;
+}
 // Instruction formats are listed in the order they appear in the RISC-V
 // instruction set manual (R, I, S, B, U, J) with sub-formats (e.g. RVInstR4,
 // RVInstRAtomic) sorted alphabetically.
diff --git a/llvm/lib/Target/RISCV/RISCVInstrInfo.td b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
index 949fff25e9e0..12141c2930d7 100644
--- a/llvm/lib/Target/RISCV/RISCVInstrInfo.td
+++ b/llvm/lib/Target/RISCV/RISCVInstrInfo.td
@@ -471,6 +471,15 @@ def JALR : RVInstI<0b000, OPC_JALR, (outs GPR:$rd),
            Sched<[WriteJalr, ReadJalr]>;
 } // hasSideEffects = 0, mayLoad = 0, mayStore = 0
 
+let hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {
+def SET_LOAD_NFU : NFUInstA<0b000, OPC_NFU, (outs), (ins uimm5:$nfu, uimm5:$mask1, uimm5:$mask2, uimm5:$mask3),
+                      "set_load_nfu", "nfu$nfu, $mask1, $mask2, $mask3">,Sched<[]>;
+def EXEC_NFU : NFUInstB<0b001, OPC_NFU, (outs), (ins uimm5:$nfu, uimm5:$rd),
+                      "exec_nfu", "nfu$nfu, $rd">,Sched<[]>;
+def POP_NFU : NFUInstB<0b010, OPC_NFU, (outs GPR:$dst), (ins uimm5:$nfu, uimm5:$rd),
+                      "pop_nfu", "$rd, nfu$nfu, $rd">,Sched<[]>;
+}
+
 def BEQ  : BranchCC_rri<0b000, "beq">;
 def BNE  : BranchCC_rri<0b001, "bne">;
 def BLT  : BranchCC_rri<0b100, "blt">;
diff --git a/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td b/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td
index 0284ff6d1c6b..ab76cd1d4c0b 100644
--- a/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td
+++ b/llvm/lib/Target/RISCV/RISCVInstrInfoVPseudos.td
@@ -4602,6 +4602,12 @@ let Predicates = [HasStdExtV, HasStdExtF] in {
   defm : VPatUnaryV_V_AnyMask<"int_riscv_vcompress", "PseudoVCOMPRESS", AllFloatVectors>;
 } // Predicates = [HasStdExtV, HasStdExtF]
 
+
+//===----------------------------------------------------------------------===//
+// 17.6.  NFU Instructions---------------------------------------------------===//
+  //def : Pat<(int_exec_nfu imm:$imm1, imm:$imm2),(EXEC_NFU uimm5:$imm1, uimm5:$imm2)>;
+  //def : Pat<(int_exec_nfu uimm5:$nfu),(EXEC_NFU uimm5:$nfu)>;
+
 // Include the non-intrinsic ISel patterns
 include "RISCVInstrInfoVSDPatterns.td"
 include "RISCVInstrInfoVVLPatterns.td"
