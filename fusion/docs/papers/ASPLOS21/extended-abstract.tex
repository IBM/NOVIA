\documentclass[pageno]{jpaper}

%replace XXX with the submission number you are given from the ASPLOS submission site.
\newcommand{\asplossubmissionnumber}{XXX}

\usepackage[normalem]{ulem}

\begin{document}

\title{Your Paper Title \\ \textbf{Extended Abstract}}

\date{}

\maketitle

\thispagestyle{empty}

% No abstract needed for the extended abstract
%\begin{abstract}
%\end{abstract}


\section{Motivation}
\label{sec:motivation}

The recent years have evidenced that Moore's law and the benefits of transistor 
scaling have become harder to exploit due to hard to overcome physical limits
that are close to be reached. In general, this means that performance no longer comes
for free from scaling down technology, but rather from the computer
architects, who have to provide better designs that improve performance rather than 
relying on the lithographic process. 

With a myriad of new applications (and their increased performance demand) oportunities for hardware and software co-design have emerged and system architecture focuses now
on designing accelerators that are tailored to specific tasks.

However the design of such accelerators is not an easy task. Hardware design 
requires expert knowledge from development to validation, it's expensive and 
takes years to deploy. Further more, with the age of accelerators coming in,
the decision on which parts of the computation should be accelerated poses important
challenges to system designers. More often than not, these requires expert knowledge
and intuition which sometimes it's either not available or conforms to human biases 
which might lead to suboptimal accelerated units. For instance, a human designer
might be aware of the logical structure of functions across a program and decide
to create an accelerator starting from such logical structure, 
however that might not be the most optimal approach. Additionally, a human designer might also be unaware of all the intrinsic common computation that spreads accross software structures and that do not follow strictly human logic. This calls for systemic
and methodological approaches that ease the effort of deriving and implementing
the new hardware accelerators.

Overall, current accelerator design is a costly effort, tailored to specific needs,
dependant on expertis and precludes hardware agile design, which slows-down the fast peaced software design environment which has to wait for years for the accelerators
to provide the necessary performance to provide optimal solutions.
Moreover, the amount of investment necessary to develop such accelerators anchors
future software developments to those past desgins in order to maximize return
on investment.

Even if all the previous facts are accounted for, the integration of such accelerators
has important implications. Offload accelerators are easy to integrate through bus interconnects and memory mapped IO, but offer poor bandwidth and if the data has to move back and forth, many acceleration opportunties are lost. Inline accelerators fill
the memory gap, but induce changes in the ISA in form of new instructions which 
often to no offer enough benefit to justify ISA manipulation due to being tailored to a specific task and subject to change in further software iterations.

Our paper tackles precisly the challenge of coming up with the optimal acceleratable
unit that requires minimal area and maximizes performance. Our methodology deals
with the software definition of computation at source code level and comes up with a
stand-alone inline accelerator that benefits from commonalities across different computation regions to automatically derive an area optimized accelerator.


\section{Limitations of the State of the Art}
\label{sec:limitations}

Current techniques on agile hardware design are mainly based around HLS methodology.
However this techniques do not focus on finding the specific sections worthy
of acceleration but rather focus on providing a functional translation of 
the software into the hardwre, which more often than not are not as efficient 
as human designed accelerators. 

Techniques that deal with searching worthy acceleratable units either have a more human-like approach design (e.g. function level) or focus on a narrow fine-grain excerpts of programs~\cite{RegionSeeker}, both of which miss out on oportunities for optimization in terms of area and performance. 


\section{Key Insights}
\label{sec:key-insights}

\begin{itemize}
  \item Our methodology discovers minimal acceleratable kernels that share patterns
    accross applications.
  \item An agile hardware development methodology that improvies new hardware accelerator development time.
\end{itemize}


\section{Main Artifacts}
\label{sec:main-artifacts}

\begin{itemize}
  \item A methodology to discover and derive inline accelerators that minimze area while maximizing performance.
  \item An ISA agnostic toolset that analyzes source code and applies an agile hardware discovery methodology.
  \item An in-depth analysis of the capabilities of the tool and methodology as long as acceleratable oportunities within the well-known SPEC CPU benchmarks.
\end{itemize}

\section{Key Results and Contributions}
\label{sec:key-contributions}
\begin{itemize}
  \item We develop a methodology to automatically discover efficient acceleration opportunities across software.
  \item We show that there are unconventional acceleration opportunities that lay outside the common logical program structure.
  \item We demonstrate that our methodology and toolset is able to extract those unconventional acceleration opportunities.
  \item We propose a series of inline accelerators that improve SPEC CPU performance by XX\% while achieving an area reduction of XX\% with respect their stand-alone versions.
\end{itemize}

\section{Why ASPLOS}
\label{sec:why-asplos}

Our contribution tackles the domains of unconventional computing systems and
heterogeneous architectures and accelerators as the purpose of the methodology
and toolchain is to enable the auomatic discovery of accelerators that are not
obvious to the human designer. Additionally, we also deal with the architectural 
support for such accelerators and how to seamlessly enable new instructions and
expose them to the software layer.


\section{Citation for Most Influential Paper Award}
\label{sec:citation}

{\color{red}I do not know how to handle this}

\section{Revisions}
\label{sec:revisions}

This paper is an original submission and has not been externally reviewed.

 
\pagebreak
\bibliographystyle{plain}
\bibliography{references}


\end{document}

